import { DomPath } from "./dom";
import { BuildId } from "./handle";
import { AdaptElement, AdaptElementOrNull, AnyProps, AnyState, BuiltinProps, Component, SFC } from "./jsx";
/**
 * An array of {@link StyleRule}s
 * @public
 */
export declare type StyleList = StyleRule[];
/**
 * Informational object provided to the callback of a
 * {@link rule}.
 * @public
 */
export interface StyleBuildInfo extends BuildId {
    origBuild: SFC;
    origElement: any;
}
/** @internal */
export declare const $matchInfoReg: unique symbol;
/** @internal */
export interface StyleBuildInfoInternal extends StyleBuildInfo {
    [$matchInfoReg]: MatchInfoReg;
}
export declare type BuildOverride<P = AnyProps> = (props: P & BuiltinProps, info: StyleBuildInfo) => AdaptElementOrNull;
export interface StyleRule {
    selector: string;
    sfc: BuildOverride;
    match(path: DomPath): boolean;
}
export interface RawStyle {
    selector: string;
    build: BuildOverride;
}
export declare type AbstractComponentCtor<P extends object = AnyProps, S extends object = AnyState, T extends Component<P, S> = Component<P, S>> = Function & {
    prototype: T;
};
export declare type AdaptComponentConstructor = new (props: AnyProps) => Component<AnyProps, AnyState>;
export interface StyleProps {
    children: (AbstractComponentCtor | SFC | string | AdaptComponentConstructor | Rule)[];
}
export declare class Rule<P = AnyProps> {
    readonly override: BuildOverride<P>;
    constructor(override: BuildOverride<P>);
}
export declare function rule<P = AnyProps>(override?: BuildOverride<P>): Rule<P>;
/**
 * Keep track of which rules have matched for a set of props so that in the
 * typical case, the same rule won't match the same component instance more
 * than once.
 * @internal
 */
export interface MatchInfo {
    matched?: Set<StyleRule>;
    neverMatch?: true;
}
export declare type MatchInfoReg = Map<AdaptElement, MatchInfo>;
export declare function createMatchInfoReg(): Map<AdaptElement<AnyProps>, MatchInfo>;
export declare function ruleHasMatched(reg: MatchInfoReg, el: AdaptElement, r: StyleRule): boolean;
export declare function ruleMatches(reg: MatchInfoReg, el: AdaptElement, r: StyleRule): void;
export declare function neverMatch(reg: MatchInfoReg, el: AdaptElement): void;
export declare function canMatch(reg: MatchInfoReg, el: AdaptElement): boolean;
export declare function copyRuleMatches(reg: MatchInfoReg, fromEl: AdaptElement, toEl: AdaptElement): void;
/**
 * Marks an element returned by a style rule to not rematch that rule.
 *
 *  @param info - The second argument to a rule callback
 *     function. This indicates which rule to ignore matches of.
 * @param elem - The element that should not match the
 *     specified rule.
 * @returns `elem` is returned as a convenience
 *
 * @remarks
 * This function can be used in a style rule build function to
 * mark the props of the passed in element such that the rule associated
 * with the info parameter will not match against the specified element.
 *
 * This works by copying the set of all rules that have already matched
 * successfully against the original element (origElement) specified in the
 * info parameter onto the passed in elem.
 *
 * @example
 * ```tsx
 * <Style>
 *   {MyComponent} {Adapt.rule<MyComponentProps>(({ handle, ...props}, info) =>
 *     ruleNoRematch(info, <MyComponent {...props} />))}
 * </Style>
 * ```
 *
 * @public
 */
export declare function ruleNoRematch(info: StyleBuildInfo, elem: AdaptElement): AdaptElement<AnyProps>;
export declare function buildStyles(styleElem: AdaptElement | null): StyleList;
export declare function findElementsInDom(stylesIn: StyleList | AdaptElement | null, dom: AdaptElementOrNull): AdaptElement[];
export declare function findPathsInDom(stylesIn: StyleList | AdaptElement | null, dom: AdaptElementOrNull): DomPath[];
export declare class Style extends Component<StyleProps> {
    build(): null;
}
/**
 * Concatenate all of the rules of the given Style elements
 * together into a single Style element that contains all of the
 * rules. Always returns a new Style element and does not modify
 * the Style element parameters.
 *
 * @param styles -
 *   Zero or more Style elements, each containing style rules.
 * @returns
 *   A new Style element containing the concatenation of all
 *   of the rules from the passed in Style elements.
 * @public
 */
export declare function concatStyles(...styles: AdaptElement[]): AdaptElement;
//# sourceMappingURL=css.d.ts.map