"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("@adpt/utils");
const util = tslib_1.__importStar(require("util"));
const deploy_1 = require("../deploy");
const handle_1 = require("../handle");
const jsx_1 = require("../jsx");
const group_1 = require("./group");
function toHandle(val) {
    return jsx_1.isElement(val) ? val.props.handle : val;
}
function handleDependsOn(h, dependency) {
    const orig = h.mountedOrig;
    if (!orig)
        return;
    orig.addDependency(dependency);
}
/**
 * Component that deploys its children sequentially.
 * @public
 */
function Sequence(props) {
    const origChildren = jsx_1.childrenToArray(props.children).filter(utils_1.notNull);
    const newProps = {
        key: props.key,
        origChildren,
    };
    return jsx_1.createElement(SequenceDeferred, newProps, origChildren);
}
exports.Sequence = Sequence;
function nextBuilt(el, skip) {
    const next = el.props.handle.nextMounted((e) => e !== skip && jsx_1.isMountedElement(e) && e.built());
    return next === skip ? undefined : next;
}
class SequenceDeferred extends jsx_1.DeferredComponent {
    constructor() {
        super(...arguments);
        // Don't show status for this component unless requested
        this.deployedWhenIsTrivial = true;
        this.deployedWhen = (_goalStatus, helpers) => {
            const unready = jsx_1.childrenToArray(this.props.children)
                .map((k) => jsx_1.isElement(k) ? k.props.handle : handle_1.isHandle(k) ? k : null)
                .filter(utils_1.notNull)
                .filter((h) => !helpers.isDeployed(h));
            return unready.length === 0 ? true :
                deploy_1.waiting(`Waiting on ${unready.length} child elements`, unready);
        };
    }
    build() {
        const props = this.props;
        const origKids = props.origChildren;
        let prev;
        for (const k of origKids) {
            if (!handle_1.isHandle(k) && !jsx_1.isElement(k)) {
                throw new Error("Children of a Sequence component must be an " +
                    "Element or Handle. Invalid child: " + util.inspect(k));
            }
            const kHandle = toHandle(k);
            // Only Elements inside the Sequence get dependencies. Handles
            // inside a sequence don't get any new dependencies.
            if (prev && jsx_1.isElement(k)) {
                for (let el = nextBuilt(k); el != null; el = nextBuilt(el, el)) {
                    handleDependsOn(el.props.handle, prev);
                }
            }
            prev = kHandle;
        }
        const finalKids = jsx_1.childrenToArray(props.children).filter(jsx_1.isElement);
        if (finalKids.length === 0)
            return null;
        return jsx_1.createElement(group_1.Group, { key: props.key }, finalKids);
    }
}
//# sourceMappingURL=sequence.js.map