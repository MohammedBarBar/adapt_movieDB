"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const error_1 = require("../error");
const server_1 = require("../server");
const deployment_1 = require("../server/deployment");
const buildAndDeploy_1 = require("./buildAndDeploy");
const common_1 = require("./common");
const fork_1 = require("./fork");
const defaultOptions = {};
async function fetchStatus(options) {
    const finalOptions = Object.assign({}, common_1.defaultDeployCommonOptions, defaultOptions, options);
    const { adaptUrl, client, deployID, logger: _logger, loggerId } = finalOptions, buildOpts = tslib_1.__rest(finalOptions, ["adaptUrl", "client", "deployID", "logger", "loggerId"]);
    const setup = {
        name: "fetchStatus",
        description: "Fetching deployment status",
        client,
        logger: _logger,
        loggerId,
    };
    return common_1.withOpsSetup(setup, async (info) => {
        const { logger, taskObserver } = info;
        try {
            const tasks = taskObserver.childGroup().add({
                load: "Getting deployment information",
                compile: "Compiling project",
                status: "Querying status",
            });
            const currState = await tasks.load.complete(async () => {
                const server = await server_1.adaptServer(adaptUrl, {});
                const deployment = await deployment_1.loadDeployment(server, deployID);
                return buildAndDeploy_1.currentState(Object.assign({ deployment,
                    taskObserver }, buildOpts));
            });
            let result;
            let needsData;
            await buildAndDeploy_1.withContext(currState, async (ctx) => {
                result = await tasks.status.complete(() => buildAndDeploy_1.build(Object.assign({}, currState, { taskObserver,
                    ctx, withStatus: true })));
                const inAdapt = ctx.Adapt;
                needsData = inAdapt.internal.simplifyNeedsData(result.needsData);
            });
            if (result === undefined)
                throw new error_1.InternalError("result undefined, should be unreachable");
            if (needsData === undefined)
                throw new error_1.InternalError("needsData undefined, should be unreachable");
            return {
                type: "success",
                messages: logger.messages,
                summary: logger.summary,
                domXml: result.domXml,
                stateJson: result.prevStateJson,
                deployID: options.deployID,
                needsData,
                mountedOrigStatus: result.mountedOrigStatus,
            };
        }
        catch (err) {
            logger.error(`Error fetching deployment status: ${err}`);
            return {
                type: "error",
                messages: logger.messages,
                summary: logger.summary,
                domXml: err.domXml,
            };
        }
    });
}
exports.fetchStatus = fetchStatus;
fork_1.forkExports(module, "fetchStatus");
//# sourceMappingURL=fetchStatus.js.map