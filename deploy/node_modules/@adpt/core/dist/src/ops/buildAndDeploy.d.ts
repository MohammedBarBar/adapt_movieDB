import { Omit, TaskObserver } from "@adpt/utils";
import { ProcessStateUpdates } from "../dom";
import { AdaptMountedElement, FinalDomElement } from "../jsx";
import { ExecutedQuery } from "../observers";
import { Deployment } from "../server/deployment";
import { DeployOpID } from "../server/deployment_data";
import { HistoryEntry } from "../server/history";
import { StateStore } from "../state";
import { Status } from "../status";
import { AdaptContext } from "../ts";
import { DeployState } from "./common";
export interface BuildOptions {
    debug: string;
    deployment: Deployment;
    dryRun: boolean;
    fileName: string;
    taskObserver: TaskObserver;
    deployOpID?: DeployOpID;
    withStatus?: boolean;
    observationsJson?: string;
    prevStateJson?: string;
    projectRoot?: string;
    stackName?: string;
}
export declare type CommitData = Omit<HistoryEntry, "fileName" | "projectRoot" | "stackName" | "stateJson">;
export interface FullBuildOptions extends Required<BuildOptions> {
    ctx?: AdaptContext;
    commit: (entry: CommitData) => Promise<void>;
    stateStore: StateStore;
    prevDomXml: string | undefined;
}
export declare function computePaths(options: BuildOptions): {
    fileName: string;
    projectRoot: string;
};
export declare function currentState(options: BuildOptions): Promise<FullBuildOptions>;
interface ExecutedQueries {
    [name: string]: ExecutedQuery[];
}
export interface BuildResults extends FullBuildOptions {
    builtElements: AdaptMountedElement[];
    domXml: string;
    mountedOrigStatus: Status;
    executedQueries: ExecutedQueries;
    needsData: ExecutedQueries;
    newDom: FinalDomElement | null;
    processStateUpdates: ProcessStateUpdates;
}
export declare function build(options: FullBuildOptions): Promise<BuildResults>;
interface ObserveResults extends FullBuildOptions {
    needsData: ExecutedQueries;
}
interface ObserveOptions extends ObserveResults {
    executedQueries: ExecutedQueries;
}
export declare function observe(options: ObserveOptions): Promise<ObserveResults>;
export declare function withContext<T>(options: FullBuildOptions, f: (ctx: AdaptContext) => T | Promise<T>): Promise<T>;
export interface DeployPassOptions extends FullBuildOptions {
    actTaskObserver: TaskObserver;
    dataDir: string;
    prevDom: FinalDomElement | null;
}
export interface DeployPassResults extends BuildResults {
    deployComplete: boolean;
    stateChanged: boolean;
}
export declare function deployPass(options: DeployPassOptions): Promise<DeployPassResults>;
export declare function buildAndDeploy(options: BuildOptions): Promise<DeployState>;
export {};
//# sourceMappingURL=buildAndDeploy.d.ts.map