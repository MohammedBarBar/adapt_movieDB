"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@adpt/utils");
const stream_1 = require("stream");
function isDeploySuccess(val) {
    return val.type === "success";
}
exports.isDeploySuccess = isDeploySuccess;
exports.defaultDeployCommonOptions = {
    debug: "",
    dryRun: false,
    projectRoot: undefined,
};
async function setupLogger(options) {
    const loggerId = options.loggerId || "main";
    if (process.env.ADAPT_OP_FORKED) { // child process
        return new utils_1.MessageStreamServer(loggerId, {
            outStream: process.stdout,
            interceptStdio: true,
        });
    }
    if (utils_1.isMessageLogger(options.logger))
        return options.logger;
    if (utils_1.isMessageClient(options.client)) {
        if (!options.client.fromStream) {
            throw new Error(`MessageClient does not support fromStream`);
        }
        const thru = new stream_1.PassThrough();
        const logger = new utils_1.MessageStreamServer(loggerId, { outStream: thru });
        options.client.fromStream(thru);
        return logger;
    }
    return new utils_1.MessageStreamer(loggerId, {
        outStream: process.stdout,
        errStream: process.stderr,
    });
}
function parseDebugString(s) {
    const flags = {};
    s.split(/\s*,\s*/).map((f) => flags[f] = true);
    return flags;
}
exports.parseDebugString = parseDebugString;
async function withOpsSetup(options, func) {
    const logger = await setupLogger(options);
    const taskObserver = utils_1.createTaskObserver(options.name, {
        logger,
        description: options.description,
    });
    try {
        taskObserver.started();
        const ret = await func({ logger, taskObserver });
        taskObserver.complete();
        return ret;
    }
    catch (err) {
        const msg = `Error ${options.description}: ${utils_1.formatUserError(err)}`;
        logger.error(msg);
        taskObserver.failed(msg);
        const ret = {
            type: "error",
            messages: logger.messages,
            summary: logger.summary,
        };
        return ret;
    }
}
exports.withOpsSetup = withOpsSetup;
//# sourceMappingURL=common.js.map