/// <reference types="node" />
import { Logger, MessageLogger, TaskObserver } from "@adpt/utils";
import { DomDiff } from "../dom_utils";
import { Handle } from "../handle";
import { AdaptElementOrNull, AdaptMountedElement, FinalDomElement } from "../jsx";
import { Deployment } from "../server/deployment";
import { DeployOpID } from "../server/deployment_data";
import { Status } from "../status";
export declare enum DeployStatus {
    Initial = "Initial",
    Waiting = "Waiting",
    Deploying = "Deploying",
    Destroying = "Destroying",
    Deployed = "Deployed",
    Failed = "Failed",
    Destroyed = "Destroyed"
}
export declare function isDeployStatus(val: any): val is DeployStatus;
export declare enum InternalStatus {
    ProxyDeploying = "ProxyDeploying",
    ProxyDestroying = "ProxyDestroying"
}
export declare type DeployStatusExt = DeployStatus | InternalStatus;
export declare const DeployStatusExt: {
    [x: number]: string;
    ProxyDeploying: InternalStatus.ProxyDeploying;
    ProxyDestroying: InternalStatus.ProxyDestroying;
    Initial: DeployStatus.Initial;
    Waiting: DeployStatus.Waiting;
    Deploying: DeployStatus.Deploying;
    Destroying: DeployStatus.Destroying;
    Deployed: DeployStatus.Deployed;
    Failed: DeployStatus.Failed;
    Destroyed: DeployStatus.Destroyed;
};
export declare function toDeployStatus(stat: DeployStatusExt): DeployStatus;
export declare type FinalStatus = DeployStatus.Deployed | DeployStatus.Destroyed | DeployStatus.Failed;
export declare function isFinalStatus(ds: DeployStatusExt): ds is FinalStatus;
/**
 * During a deploy operation for a resource or set of resources, the
 * intended final status for the resource.
 *
 * @remarks
 *
 * - `GoalStatus.Deployed`
 *
 * The operation is attempting to deploy a resource. This includes creation or
 * updating of a resource.
 *
 * - `GoalStatus.Destroyed`
 *
 * The operation is attempting to destroy a resource.
 * @public
 */
export declare type GoalStatus = DeployStatus.Deployed | DeployStatus.Destroyed;
export declare const GoalStatus: {
    Deployed: GoalStatus;
    Destroyed: GoalStatus;
};
export declare function isGoalStatus(ds: DeployStatusExt): ds is GoalStatus;
export declare function goalToInProgress(stat: GoalStatus): DeployStatus.Deploying | DeployStatus.Destroying;
export declare function isInProgress(stat: DeployStatusExt): boolean;
export declare function isProxying(stat: DeployStatusExt): boolean;
export declare enum DeployOpStatusExt {
    StateChanged = "StateChanged"
}
export declare type DeployOpStatus = DeployStatus | DeployOpStatusExt;
export declare const DeployOpStatus: {
    [x: number]: string;
    StateChanged: DeployOpStatusExt.StateChanged;
    Initial: DeployStatus.Initial;
    Waiting: DeployStatus.Waiting;
    Deploying: DeployStatus.Deploying;
    Destroying: DeployStatus.Destroying;
    Deployed: DeployStatus.Deployed;
    Failed: DeployStatus.Failed;
    Destroyed: DeployStatus.Destroyed;
};
export declare type PluginKey = string;
export declare type PluginInstances = Map<PluginKey, Plugin>;
export declare type PluginModules = Map<PluginKey, PluginModule>;
export interface PluginRegistration {
    name: string;
    module: NodeModule;
    create(): Plugin;
}
export interface PluginModule extends PluginRegistration {
    packageName: string;
    version: string;
}
export interface PluginConfig {
    plugins: PluginInstances;
    modules: PluginModules;
}
export declare enum ChangeType {
    none = "none",
    create = "create",
    delete = "delete",
    modify = "modify",
    replace = "replace"
}
/**
 * Describes the effect an Action has on a specific Element
 * @remarks
 * type and detail here explain how the Action affects this specific
 * element, which may or may not be different than the action. For example,
 * an Action that performs a modify on a CloudFormation stack may cause
 * certain Elements to be created and deleted within that Action.
 * @public
 */
export interface ActionChange {
    type: ChangeType;
    element: FinalDomElement;
    detail: string;
}
/**
 * Describes the overall effect that an Action is performing.
 * @remarks
 * `type` and `detail` here explain what the Action is doing overall, not how it
 * affects any particular Element.
 * @public
 */
export interface ActionInfo {
    type: ChangeType;
    detail: string;
    changes: ActionChange[];
}
export interface Action extends ActionInfo {
    act(): Promise<void>;
}
export interface PluginOptions {
    deployID: string;
    log: Logger;
    logger: MessageLogger;
    dataDir: string;
}
export interface PluginObservations {
    [pluginKey: string]: object;
}
export interface Plugin<Observations extends object = object> {
    start(options: PluginOptions): Promise<void>;
    observe(prevDom: AdaptElementOrNull, dom: AdaptElementOrNull): Promise<Observations>;
    analyze(prevDom: AdaptElementOrNull, dom: AdaptElementOrNull, obs: Observations): Action[];
    finish(): Promise<void>;
}
export interface PluginManagerStartOptions {
    deployment: Deployment;
    logger: MessageLogger;
    dataDir: string;
}
export interface ActOptions {
    builtElements: AdaptMountedElement[];
    concurrency?: number;
    deployOpID: DeployOpID;
    dryRun?: boolean;
    goalStatus?: GoalStatus;
    pollDelayMs?: number;
    processStateUpdates?: () => Promise<{
        stateChanged: boolean;
    }>;
    taskObserver: TaskObserver;
    timeoutMs?: number;
}
export interface ActComplete {
    deployComplete: boolean;
    stateChanged: boolean;
}
/**
 * Relations are used to describe the logic of when an object will be ready.
 *
 * @remarks
 * Relations are primarily used to describe deployment dependencies in Adapt.
 * They can be combined together to express boolean logic, so you can express
 * things like "A is ready when B and C are ready":
 *
 * Relations should usually be created using the supplied library functions.
 * The most commonly used Relation functions are the high-level functions.
 * The high-level Relation functions interact with the Adapt deployment engine
 * for determining whether components have been deployed. These functions are
 * useful in a {@link Component.dependsOn} method for describing what a
 * component depends on.
 *
 * Examples of the more commonly used high-level Relation functions are:
 *   - `Only()` - Creates a `Relation` that is ready when a single dependency
 *     has been deployed.
 *   - `AllOf()` - Creates a `Relation` that's ready when all of a given set
 *     of dependencies have been deployed.
 *   - `AnyOf()` - Creates a `Relation` that's ready when any of a given set
 *     of dependencies have been deployed.
 *
 * Examples of low-level Relation functions are:
 *   - `True()` - Creates a `Relation` that's always ready.
 *   - `False()` - Creates a `Relation` will never be ready.
 *   - `And()` - Creates a `Relation` that becomes ready when all of its
 *      arguments are ready.
 *   - `Edge()` - Creates a `Relation` that checks the deployment status of
 *      an object to determine readiness.
 * @public
 */
export interface Relation {
    description: string;
    ready: (relatesTo: Relation[]) => true | Waiting | Waiting[];
    inverse?: (relatesTo: Relation[]) => Relation;
    relatesTo?: Relation[];
    toString?: (indent?: string) => string;
}
export interface RelationExt extends Relation {
    toDependencies?: () => Dependency[];
}
export declare function isRelation(v: any): v is Relation;
export declare type RelationOp = (...args: Relation[]) => Relation;
export declare type DependsOn = Relation;
export declare type DependsOnMethod = (goalStatus: GoalStatus, helpers: DeployHelpers) => DependsOn | undefined;
/**
 * A function that gives information about whether an Element has finished
 * deploying.
 *
 * @remarks
 * Components may provide a custom `deployedWhen` method to directly control
 * when the component can be considered fully deployed. For class-based
 * components, see {@link Component.deployedWhen}. For function components,
 * see {@link useDeployedWhen}.
 *
 * During a deployment operation, an Element's `deployedWhen` function will be
 * executed by the system to determine if the Element has reached its
 * `goalStatus`. The provided function will **not** be called until after
 * all of the component's dependencies have been met, but then may be polled
 * repeatedly.
 *
 * An example use of a `deployedWhen` function might be to have a component
 * be considered deployed once any one of its children are deployed.
 *
 * A `deployedWhen` function can also be used to check external resources,
 * such as with a CLI command or via an API or network call. For example,
 * if your component deploys a network service, its `deployedWhen` method
 * could make a network request to the service and return `true` (deployed)
 * once it connects successfully to the service.
 *
 * Important: A `deployedWhen` function should always check the
 * `goalStatus` parameter to determine whether the component is being
 * deployed or destroyed and modify its behavior accordingly. For example,
 * if your `deployedWhen` calls an API function to confirm a resource has
 * been created when `goalStatus` is `GoalStatus.Deployed`, then when
 * `goalStatus` is `GoalStatus.Destroyed`, you may need to call an API
 * function to confirm that the resource has been deleted.
 *
 * For components that do not add a custom `deployedWhen` method, the
 * default behavior is that a component becomes deployed when all of it's
 * successors and children have been deployed. See {@link defaultDeployedWhen}
 * for more information.
 *
 * @public
 */
export declare type DeployedWhenMethod = (goalStatus: GoalStatus, helpers: DeployHelpers) => WaitStatus | Promise<WaitStatus>;
export declare type Dependency = Handle | DependsOn;
export declare const isDependsOn: typeof isRelation;
export interface Waiting {
    done: false;
    status: string;
    related?: Waiting[];
    /**
     * Handles for any Elements that must become deployed in order to become
     * ready and stop waiting.
     */
    toDeploy?: Handle[];
}
export declare type WaitStatus = true | Waiting | Waiting[];
export declare type IsDeployedFunc = (dep: Dependency) => boolean;
export interface DeployHelpers {
    elementStatus: <S extends Status = Status>(handle: Handle) => Promise<S | Status | undefined>;
    isDeployed: IsDeployedFunc;
    dependsOn: (dep: Handle | Handle[]) => Relation;
}
export interface PluginManager {
    start(prevDom: AdaptElementOrNull, dom: AdaptElementOrNull, options: PluginManagerStartOptions): Promise<void>;
    observe(): Promise<PluginObservations>;
    analyze(): Action[];
    act(options: ActOptions): Promise<ActComplete>;
    finish(): Promise<void>;
}
export interface ExecutionPlanOptions {
    actions: Action[];
    builtElements: AdaptMountedElement[];
    deployment: Deployment;
    deployOpID: DeployOpID;
    diff: DomDiff;
    goalStatus: GoalStatus;
}
export interface ExecutionPlan {
    check(): void;
}
export interface ExecuteOptions {
    concurrency?: number;
    dryRun?: boolean;
    logger: MessageLogger;
    plan: ExecutionPlan;
    pollDelayMs?: number;
    processStateUpdates: () => Promise<{
        stateChanged: boolean;
    }>;
    taskObserver: TaskObserver;
    timeoutMs?: number;
}
export interface ExecuteComplete {
    deploymentStatus: DeployOpStatus;
    nodeStatus: Record<DeployStatus, number>;
    primStatus: Record<DeployStatus, number>;
    nonPrimStatus: Record<DeployStatus, number>;
    stateChanged: boolean;
}
//# sourceMappingURL=deploy_types.d.ts.map