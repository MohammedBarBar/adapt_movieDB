"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@adpt/utils");
const lodash_1 = require("lodash");
const handle_1 = require("../handle");
const relation_utils_1 = require("./relation_utils");
exports.waiting = (status, related) => {
    const ret = { done: false, status };
    if (related) {
        const hands = [];
        const waits = [];
        for (const r of related) {
            if (handle_1.isHandle(r))
                hands.push(r);
            else
                waits.push(r);
        }
        if (hands.length > 0)
            ret.toDeploy = hands;
        if (waits.length > 0)
            ret.related = waits;
    }
    return ret;
};
// tslint:disable: variable-name
exports.True = () => ({
    description: "True",
    ready: () => true,
});
exports.False = () => ({
    description: "False",
    ready: () => exports.waiting("False is never ready"),
});
exports.Identity = (a0) => ({
    description: "",
    ready: (args) => relation_utils_1.relationIsReadyStatus(args[0]),
    relatesTo: [a0],
});
exports.Not = (a0) => ({
    description: "Not",
    ready: (args) => {
        const stat = relation_utils_1.relationIsReadyStatus(args[0]);
        if (stat !== true)
            return true;
        return exports.waiting("Not ready because child Relation is ready");
    },
    relatesTo: [a0],
});
exports.And = (...relatesTo) => relatesTo.length === 0 ? exports.True() :
    relatesTo.length === 1 ? relatesTo[0] :
        {
            description: "And",
            ready: (rList) => {
                const status = relation_utils_1.relationIsReadyStatus(rList);
                if (status === true)
                    return true;
                const notReady = utils_1.toArray(status);
                return exports.waiting(`Waiting for ${relation_utils_1.nDepends(notReady.length)}`, notReady);
            },
            relatesTo,
        };
exports.Or = (...relatesTo) => relatesTo.length === 0 ? exports.True() :
    relatesTo.length === 1 ? relatesTo[0] :
        {
            description: "Or",
            ready: (rList) => {
                const status = relation_utils_1.relationIsReadyStatus(rList);
                if (status === true)
                    return true;
                const notReady = utils_1.toArray(status);
                if (notReady.length < rList.length)
                    return true;
                return exports.waiting(`Waiting for any of ${relation_utils_1.nDepends(notReady.length)}`, notReady);
            },
            relatesTo,
        };
exports.Edge = (a0, a1, isDeployed) => ({
    get description() { return this.toString(); },
    ready: () => {
        if (isDeployed(a1))
            return true;
        return exports.waiting(`Waiting for dependency ${relation_utils_1.depName(a1)}`);
    },
    inverse: () => exports.Edge(a1, a0, isDeployed),
    toString: (indent = "") => `${indent}Edge( ${relation_utils_1.depName(a0)}, ${relation_utils_1.depName(a1)} )`,
    toDependencies: () => [a1],
});
exports.Value = (v, description = "Value") => ({
    description,
    ready: () => {
        if (lodash_1.isFunction(v) ? v() : v)
            return true;
        return exports.waiting(`Waiting for ${description}`);
    },
    toString: (indent = "") => {
        return `${indent}${description}(${typeof v === "boolean" ? v : "<function>"})`;
    }
});
function AllOf(h, deps) {
    return {
        description: "all of",
        relatesTo: deps.map((d) => relation_utils_1.toRelation(h, d)),
        ready: (rels) => relation_utils_1.relationIsReadyStatus(exports.And(...rels)),
    };
}
exports.AllOf = AllOf;
function Only(h, dep) {
    return {
        description: "only",
        relatesTo: [relation_utils_1.toRelation(h, dep)],
        ready: (rels) => relation_utils_1.relationIsReadyStatus(rels[0]),
    };
}
exports.Only = Only;
function AnyOf(h, deps) {
    return {
        description: "any of",
        relatesTo: deps.map((d) => relation_utils_1.toRelation(h, d)),
        ready: (rels) => relation_utils_1.relationIsReadyStatus(exports.Or(...rels)),
    };
}
exports.AnyOf = AnyOf;
function None() {
    return {
        description: "none",
        ready: () => true,
    };
}
exports.None = None;
//# sourceMappingURL=relations.js.map