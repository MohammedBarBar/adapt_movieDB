"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@adpt/utils");
const lodash_1 = require("lodash");
const handle_1 = require("../handle");
const jsx_1 = require("../jsx");
const isWaiting = (val) => val !== true;
exports.relationIsReadyStatus = (rels) => {
    const status = (r) => r.ready(r.relatesTo || []);
    rels = utils_1.toArray(rels);
    const notReady = lodash_1.flatten(rels.map(status).filter(isWaiting));
    return notReady.length === 0 ? true :
        notReady.length === 1 ? notReady[0] :
            notReady;
};
exports.relationIsReady = (r) => exports.relationIsReadyStatus(r) === true;
exports.relationInverse = (r) => {
    const relatesTo = r.relatesTo ?
        r.relatesTo.map((a) => exports.relationInverse(a)) : [];
    if (r.inverse)
        return r.inverse(relatesTo);
    return Object.assign({}, r, { relatesTo });
};
exports.relationToString = (r, indent = "") => {
    if (Object.prototype.hasOwnProperty.call(r, "toString") && r.toString) {
        return r.toString(indent);
    }
    const relatesTo = r.relatesTo || [];
    const args = relatesTo.length === 0 ? "" :
        `\n${relatesTo.map((a) => exports.relationToString(a, indent + "  ")).join(",\n")}\n${indent}`;
    return `${indent}${r.description}(${args})`;
};
exports.waitStatusToString = (s) => s === true ? "Ready" :
    !Array.isArray(s) ? s.status :
        ["Waiting for:", ...s.map((w) => w.status)].join("\n");
function depName(d) {
    if (handle_1.isHandle(d)) {
        const target = d.target;
        if (target) {
            let id = jsx_1.isMountedElement(target) ? target.id : target.componentName;
            if (d.name)
                id += ` (${d.name})`;
            return id;
        }
        if (d.name)
            return `Handle(${d.name})`;
        return d.toString();
    }
    return `Dep(${d.description})`;
}
exports.depName = depName;
exports.toRelation = (h, d) => handle_1.isHandle(d) ? h.dependsOn(d) : d;
function relatedHandles(rel) {
    const handles = new Set();
    const deps = (r) => {
        exports.toDependencies(r).forEach((d) => {
            if (handle_1.isHandle(d))
                handles.add(d);
            else
                deps(d);
        });
    };
    deps(rel);
    return [...handles];
}
exports.relatedHandles = relatedHandles;
exports.toDependencies = (r) => r.toDependencies ? r.toDependencies() : r.relatesTo || [];
exports.nDepends = (count) => count === 1 ? `1 dependency` : `${count} dependencies`;
//# sourceMappingURL=relation_utils.js.map