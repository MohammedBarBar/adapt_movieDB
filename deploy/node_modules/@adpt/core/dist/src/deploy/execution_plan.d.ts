import { Graph } from "graphlib";
import { Handle } from "../handle";
import { AdaptElement, AdaptMountedElement, AnyProps, ElementID } from "../jsx";
import { Deployment } from "../server/deployment";
import { DeployOpID } from "../server/deployment_data";
import { Status } from "../status";
import { Action, Dependency, DeployHelpers, ExecuteComplete, ExecuteOptions, ExecutionPlan, ExecutionPlanOptions, GoalStatus, Relation } from "./deploy_types";
import { EPEdge, EPNode, EPNodeEl, EPNodeId, EPNodeWI, EPObject, ExecutePassOptions, StatusTracker, WaitInfo } from "./deploy_types_private";
export declare function createExecutionPlan(options: ExecutionPlanOptions): Promise<ExecutionPlan>;
export declare function getWaitInfo(goalStatus: GoalStatus, e: AdaptElement | Handle, helpers: DeployHelpers): WaitInfo;
export interface EPDependency {
    id: EPNodeId;
    type: "soft" | "hard";
}
export interface EPDependencies {
    [epNodeId: string]: {
        elementId?: ElementID;
        detail: string;
        deps: EPDependency[];
    };
}
export interface ExecutionPlanImplOptions {
    deployment: Deployment;
    deployOpID: DeployOpID;
    goalStatus: GoalStatus;
}
export declare class ExecutionPlanImpl implements ExecutionPlan {
    readonly deployment: Deployment;
    readonly deployOpID: DeployOpID;
    readonly goalStatus: GoalStatus;
    readonly helpers: DeployHelpersFactory;
    protected graph: Graph;
    protected nextWaitId: number;
    protected waitInfoIds: WeakMap<WaitInfo, string>;
    protected complete: Map<string, EPNode>;
    constructor(options: ExecutionPlanImplOptions);
    check(): void;
    addElem(el: AdaptMountedElement, goalStatus: GoalStatus): void;
    addAction(action: Action): EPNodeWI | undefined;
    addWaitInfo(nodeOrWI: WaitInfo | EPNodeWI, goalStatus: GoalStatus): EPNodeWI;
    /**
     * Now used only in unit test. Should eventually be removed.
     */
    updateElemWaitInfo(refresh?: boolean): void;
    addNode(node: EPNode): void;
    addHardDep(obj: EPObject, dependsOn: EPObject): void;
    removeNode(node: EPNode): void;
    predecessors(n: EPNode): EPNode[];
    successors(n: EPNode): EPNode[];
    groupLeader(n: EPObject): EPNode | undefined;
    groupFollowers(n: EPObject): EPNode[];
    setGroup(n: EPObject, leader: EPObject): void;
    readonly nodes: EPNode[];
    readonly elems: AdaptMountedElement[];
    readonly leaves: EPNode[];
    getId: (obj: EPObject, create?: boolean) => string;
    getNode: (idOrObj: string | AdaptMountedElement<AnyProps> | WaitInfo | EPNodeEl | EPNodeWI) => EPNode;
    hasNode: (idOrObj: string | AdaptMountedElement<AnyProps> | WaitInfo | EPNodeEl | EPNodeWI) => boolean;
    toDependencies(): EPDependencies;
    print(): string;
    protected getIdInternal: (obj: EPObject, create?: boolean) => string | undefined;
    protected getNodeInternal: (idOrObj: string | AdaptMountedElement<AnyProps> | WaitInfo | EPNodeEl | EPNodeWI) => EPNodeEl | EPNodeWI | undefined;
    protected getEdgeInternal: (idOrObj1: string | AdaptMountedElement<AnyProps> | WaitInfo | EPNodeEl | EPNodeWI, idOrObj2: string | AdaptMountedElement<AnyProps> | WaitInfo | EPNodeEl | EPNodeWI) => EPEdge | undefined;
    /**
     * The direction of the dependency has to be reversed for Destroy
     * so that things are destroyed in "reverse order" (actually by
     * walking the graph in the opposite order). But a single graph
     * contains some things that are being Deployed and some that are
     * being Destroyed.
     * The arguments to the function (obj, dependsOn) identify two EPNodes.
     * Each of those two EPNodes could have goalStatus Deployed or Destroyed,
     * so there are 4 possible combinations:
     *   A) Deployed, Deployed
     *      This is the simple case where `dependsOn` should be Deployed
     *      before `obj` is Deployed. The edge is `obj` -> `dependsOn`.
     *   B) Destroyed, Destroyed
     *      Also simple. If `dependsOn` must be Deployed before `obj`, then
     *      it's reversed for Destroyed and `obj` must be Destroyed before
     *      `dependsOn`. The edge is `dependsOn` -> `obj`.
     *   C) Destroyed, Deployed
     *      The valid way this can happen when used with an actual old DOM
     *      and new DOM is that `obj` is from the old DOM. The new DOM does
     *      not contain this node and therefore *cannot* have a dependency
     *      on it. The dependency here can be ignored safely. No edge.
     *   D) Deployed, Destroyed
     *      This doesn't make sense right now because there's not really a
     *      way for a "living" component in the new DOM to get a reference
     *      to something being deleted from the old DOM. This is currently
     *      an error.
     */
    protected addEdge(obj: EPObject, dependsOn: EPObject, hardDep?: boolean): void;
    protected addEdgeInternal(obj: EPObject, dependsOn: EPObject, hardDep: boolean): void;
    protected removeEdgeInternal(obj: EPObject, dependsOn: EPObject): void;
    protected addHardDepInternal(obj: EPNode, dependsOn: EPNode): void;
    protected removeHardDepInternal(obj: EPNode, dependsOn: EPNode): void;
}
export declare function isExecutionPlanImpl(val: any): val is ExecutionPlanImpl;
export declare function execute(options: ExecuteOptions): Promise<ExecuteComplete>;
export declare function executePass(opts: ExecutePassOptions): Promise<void>;
declare class DeployHelpersFactory {
    protected plan: ExecutionPlanImpl;
    elementStatus: <S extends Status = Status>(handle: Handle) => Promise<S | Status | undefined>;
    protected nodeStatus_: StatusTracker | null;
    constructor(plan: ExecutionPlanImpl, deployment: Deployment);
    nodeStatus: StatusTracker;
    isDeployed: (d: Dependency) => boolean;
    makeDependsOn: (current: Handle<import("../jsx").GenericInstance>) => (hands: Handle<import("../jsx").GenericInstance> | Handle<import("../jsx").GenericInstance>[]) => Relation;
    create: (elem: AdaptMountedElement<AnyProps>) => DeployHelpers;
}
export {};
//# sourceMappingURL=execution_plan.d.ts.map