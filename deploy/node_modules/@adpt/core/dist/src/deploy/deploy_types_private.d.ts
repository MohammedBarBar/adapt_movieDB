import { TaskObserver } from "@adpt/utils";
import { AdaptMountedElement } from "../jsx";
import { Deployment } from "../server/deployment";
import { DeployOpID, DeployStepID } from "../server/deployment_data";
import { ActionChange, DeployedWhenMethod, DeployStatus, DeployStatusExt, ExecuteComplete, ExecuteOptions, GoalStatus, RelationExt } from "./deploy_types";
export interface ExecutePassOptions extends Required<ExecuteOptions> {
    nodeStatus: StatusTracker;
    timeoutTime: number;
}
export interface WaitInfo {
    deployedWhen: (gs: GoalStatus) => ReturnType<DeployedWhenMethod>;
    description: string;
    actingFor?: ActionChange[];
    action?: () => void | Promise<void>;
    /**
     * True if there is an Action that affects this node in the current
     * execution plan.
     */
    activeAction?: boolean;
    dependsOn?: RelationExt;
    logAction?: boolean;
}
export declare function isWaitInfo(v: any): v is WaitInfo;
export interface EPNodeCommon {
    goalStatus: GoalStatus;
    hardDeps?: Set<EPNode>;
}
export interface EPNodeEl extends EPNodeCommon {
    element: AdaptMountedElement;
    waitInfo: WaitInfo;
}
export interface EPNodeWI extends EPNodeCommon {
    element?: AdaptMountedElement;
    waitInfo: WaitInfo;
}
export declare function isEPNodeWI(n: EPNode): n is EPNodeWI;
export declare type EPNode = EPNodeEl | EPNodeWI;
export declare type EPObject = EPNode | AdaptMountedElement | WaitInfo;
export declare type EPNodeId = string;
export interface EPEdge {
    hard?: boolean;
}
export interface StatusTracker {
    readonly deployment: Deployment;
    readonly dryRun: boolean;
    readonly goalStatus: GoalStatus;
    readonly nodeStatus: Record<DeployStatus, number>;
    readonly deployOpID: DeployOpID;
    readonly primStatus: Record<DeployStatus, number>;
    readonly statMap: Map<EPNode, DeployStatusExt>;
    readonly taskMap: Map<EPNode, TaskObserver>;
    readonly stepID?: DeployStepID;
    get(n: EPNode): DeployStatusExt;
    set(n: EPNode, statExt: DeployStatusExt, err: Error | undefined, description?: string): Promise<boolean>;
    isFinal(n: EPNode): boolean;
    isActive(n: EPNode): boolean;
    output(n: EPNode, s: string): void;
    complete(stateChanged: boolean): Promise<ExecuteComplete>;
    debug(getId: (n: EPNode) => string): string;
}
//# sourceMappingURL=deploy_types_private.d.ts.map