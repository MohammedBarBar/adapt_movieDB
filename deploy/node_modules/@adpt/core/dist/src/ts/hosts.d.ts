import * as ts from "./tsmod";
export declare let debugChainableHosts: boolean;
export declare let debugChainableHostsVerbose: boolean;
export declare let debugDir: boolean;
export declare abstract class ChainableHost implements ts.CompilerHost {
    readonly cwd: string;
    _id: string;
    source: ChainableHost;
    constructor(cwd: string);
    directoryExists(directoryname: string): boolean;
    fileExists(fileName: string): boolean;
    getCancellationToken(): ts.CancellationToken;
    getDefaultLibFileName(options: ts.CompilerOptions): string;
    getDirectories(path: string): string[];
    getFileVersion(fileName: string): string;
    getNewLine(): string;
    getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void): ts.SourceFile | undefined;
    readFile(fileName: string): string | undefined;
    /**
     * Should be implemented by any Host that performs filename translation.
     * Given a possibly "faked" or virtual filename, return the real filename
     * that corresponds.
     */
    realFilename(fileName: string): string | undefined;
    resolveModuleName(modName: string, containingFile: string, runnable?: boolean): ts.ResolvedModule | undefined;
    resolveModuleNames(moduleNames: string[], containingFile: string, reusedNames?: string[]): ts.ResolvedModule[];
    useCaseSensitiveFileNames(): boolean;
    writeFile(fileName: string, data: string): any;
    getCanonicalFileName(fileName: string): string;
    getCurrentDirectory(): string;
    setSource(source: ChainableHost): void;
    dir(): string[];
    dirTrace(): void;
    private canonicalizeFunc;
}
export declare class HostFinal extends ChainableHost {
    fileExists(): boolean;
    directoryExists(): boolean;
    getFileVersion(): any;
    getSourceFile(): undefined;
    useCaseSensitiveFileNames(): boolean;
    getNewLine(): string;
    getDefaultLibFileName(): string;
    resolveModuleName(): any;
    getDirectories(): never[];
    readFile(): undefined;
    getCancellationToken(): any;
    resolveModuleNames(moduleNames: string[], containingFile: string): any[];
    realFilename(): undefined;
    writeFile(): void;
    dir(): never[];
}
export declare class FileSystemHost extends ChainableHost {
    private rootDir;
    constructor(rootDir: string, cwd?: string);
    readDirectory(path: string, extensions?: ReadonlyArray<string>, excludes?: ReadonlyArray<string>, includes?: ReadonlyArray<string>, depth?: number): string[];
    getDirectories(fileName: string): string[];
    directoryExists(path: string): boolean;
    readFile(path: string, encoding?: string): string | undefined;
    getFileVersion(fileName: string): string;
    fileExists(path: string): boolean;
    realFilename(fileName: string): string;
    writeFile(): void;
    dir(): string[];
    private allowed;
}
export declare class MemoryHost extends ChainableHost {
    private files;
    private dirs;
    constructor(rootDir: string, cwd?: string);
    writeFile(path: string, data: string): void;
    readFile(path: string, encoding?: string): string | undefined;
    getFileVersion(fileName: string): string;
    fileExists(path: string): boolean;
    directoryExists(directoryName: string): boolean;
    getDirectories(path: string): string[];
    dir(): string[];
    private mkdirs;
}
export declare function chainHosts(...hosts: ChainableHost[]): ChainableHost;
export declare function MemFileHost(rootDir: string, cwd?: string): ChainableHost;
//# sourceMappingURL=hosts.d.ts.map