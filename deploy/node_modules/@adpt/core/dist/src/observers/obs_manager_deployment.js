"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
// The ObserverDeploymentManager manages the functionality needed
// to process observation queries when evaluating the state of a deployment.
//
// The ObserverDataManager (not written yet) manages fetching of observed
// data via poll or watch.
const utils_1 = require("@adpt/utils");
const graphql_1 = require("graphql");
const ld = tslib_1.__importStar(require("lodash"));
const query_transforms_1 = require("./query_transforms");
function createObserverManagerDeployment() {
    return new ObserverManagerDeploymentImpl();
}
exports.createObserverManagerDeployment = createObserverManagerDeployment;
function addExecutedQuery(o, query) {
    const key = graphql_1.print(query.query); //Would be better to have canonicalized key here
    const entry = o.get(key);
    if (entry === undefined) {
        const vars = new Set([query.variables]);
        o.set(key, { doc: query.query, vars: ld.cloneDeep(vars) });
        return;
    }
    //FIXME(manishv) If this is slow, need a better data structure for unique vars
    for (const val of entry.vars) {
        if (ld.isEqual(val, query.variables))
            return;
    }
    //If we made it here, we need to add current query variabless to the set
    entry.vars.add(query.variables);
}
function flattenExecutedQueryStorage(queries) {
    const ret = [];
    for (const val of queries.values()) {
        for (const vars of val.vars.values()) {
            ret.push({ query: val.doc, variables: vars });
        }
    }
    return ret;
}
class ObserverManagerDeploymentImpl {
    constructor() {
        this.observable = {};
        this.needsData = {};
        this.registerSchema = (observer, schema, observations) => {
            const name = observer.observerName;
            if (name in this.observable)
                throw new Error("Cannot register schema with name: " + name);
            this.observable[name] = {
                schema,
                observations,
                executedQueries: new Map()
            };
        };
        this.findObserverSchema = (observer) => {
            return this.observable[observer.observerName].schema;
        };
        this.executedQueries = () => {
            const ret = {};
            for (const schemaName in this.observable) {
                if (!Object.hasOwnProperty.call(this.observable, schemaName))
                    continue;
                ret[schemaName] = flattenExecutedQueryStorage(this.observable[schemaName].executedQueries);
            }
            return ret;
        };
        this.executedQueriesThatNeededData = () => {
            const ret = {};
            for (const schemaName in this.needsData) {
                if (!Object.hasOwnProperty.call(this.needsData, schemaName))
                    continue;
                ret[schemaName] = flattenExecutedQueryStorage(this.needsData[schemaName]);
            }
            return ret;
        };
        this.executeQuery = async (observer, q, vars) => {
            const schemaName = observer.observerName;
            if (!(schemaName in this.observable))
                throw new Error("Unknown observation schema queried: " + schemaName);
            const { schema, observations, executedQueries } = this.observable[schemaName];
            const query = { query: q, variables: vars };
            addExecutedQuery(executedQueries, query);
            const ret = await Promise.resolve(query_transforms_1.adaptGqlExecute(schema, q, observations.data, observations.context, vars));
            if (ret.errors) {
                const needDataErr = ret.errors.find((e) => e.message.startsWith("Adapt Observer Needs Data:"));
                if (needDataErr !== undefined) {
                    if (this.needsData[schemaName] === undefined) {
                        this.needsData[schemaName] = new Map();
                    }
                    addExecutedQuery(this.needsData[schemaName], query);
                }
            }
            return ret;
        };
    }
}
function simplifyNeedsData(nd) {
    const ret = {};
    for (const obsName in nd) {
        if (!Object.hasOwnProperty.call(nd, obsName))
            continue;
        ret[obsName] = nd[obsName].map((q) => {
            const vars = q.variables ? JSON.parse(JSON.stringify(q.variables)) : undefined;
            return utils_1.removeUndef(({ query: graphql_1.print(q.query), variables: vars }));
        });
    }
    return ret;
}
exports.simplifyNeedsData = simplifyNeedsData;
//# sourceMappingURL=obs_manager_deployment.js.map