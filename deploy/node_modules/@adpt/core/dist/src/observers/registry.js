"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("@adpt/utils");
const debug_1 = tslib_1.__importDefault(require("debug"));
const ld = tslib_1.__importStar(require("lodash"));
const util = tslib_1.__importStar(require("util"));
const obs_manager_deployment_1 = require("./obs_manager_deployment");
const debug = debug_1.default("adapt:observers");
const observers = {};
function makeObserverManagerDeployment(observations) {
    const mgr = obs_manager_deployment_1.createObserverManagerDeployment();
    for (const name in observers) {
        if (!Object.hasOwnProperty.call(observers, name))
            continue;
        const o = observers[name];
        const obs = observations[name];
        mgr.registerSchema({ observerName: name }, o.schema, obs ? obs.observations : {});
    }
    return mgr;
}
exports.makeObserverManagerDeployment = makeObserverManagerDeployment;
function registerObserver(obs, nameIn) {
    const constructor = obs.constructor;
    const name = nameIn ? nameIn : constructor.name;
    //FIXME(manishv) Use reanimate library to get unique names and avoid conflicts
    if (name in observers)
        throw new Error(`Attempt to register observer with duplicate name '${name}'`);
    observers[name] = obs;
    if (constructor.observerName === undefined)
        constructor.observerName = name;
    return name;
}
exports.registerObserver = registerObserver;
function findObserver(observer) {
    return observers[observer.observerName];
}
exports.findObserver = findObserver;
async function observe(executedQueries, logger = new utils_1.MessageStreamer("observe"), //Should bitbucket log messages
observerNames = Object.keys(observers)) {
    const ret = {};
    const waitFors = [];
    const errors = [];
    for (const name of observerNames) {
        const obs = observers[name];
        if (obs === undefined)
            continue; //Should this be an error instead?
        const queries = executedQueries[name] ? executedQueries[name] : [];
        const waitP = (async () => {
            try {
                debug(`starting observations for ${name} with ${queries.length} queries`);
                const observations = await obs.observe(queries);
                debug(`finished observations for ${name}`);
                ret[name] = {
                    observations,
                    queries
                };
            }
            catch (e) {
                debug(`errored observations for ${name}`);
                if (!ld.isError(e))
                    e = new Error(util.inspect(e));
                const msg = `Error observing for ${name}: ${e.message}`;
                logger.warning(msg);
                errors.push(new Error(msg));
            }
        })();
        waitFors.push(waitP);
    }
    await Promise.all(waitFors); //Should never throw/reject
    if (errors.length !== 0) {
        const msgs = errors.map((val) => val.message);
        const e = new Error("Errors during observations:\n" + msgs.join("\n"));
        e.observations = ret; //Allow storage of partial results by returning them
        throw e;
    }
    return ret;
}
exports.observe = observe;
//# sourceMappingURL=registry.js.map