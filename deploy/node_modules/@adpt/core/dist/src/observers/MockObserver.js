"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
//FIXME(manishv), this mock is here becuase it is needed in cli as well, and testutils cannot depend on Adapt.
//At some point we should have a different package for these kinds of things.
//Alternatively, this should become some sort of generic observer that makes it easier to write observers
//that follow a certain pattern.
const uutil = tslib_1.__importStar(require("@adpt/utils"));
const fs = tslib_1.__importStar(require("fs"));
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const path = tslib_1.__importStar(require("path"));
const errors_1 = require("./errors");
const registry_1 = require("./registry");
const schemaFile = path.join(__dirname, "mock_observer.graphql");
const schemaStr = fs.readFileSync(schemaFile).toString();
//Resolve data from previously fetched results.
const queryCacheResolvers = {
    Query: {
        mockById: async (_obj, args, cache, _info) => {
            await uutil.sleep(0);
            const ret = cache ? cache.mockObjects.find((o) => o.id === args.id) : undefined;
            if (ret !== undefined)
                return ret;
            //Can there be such an object?
            const id = Number(args.id);
            if (Number.isNaN(id))
                return null; //No such object
            if (Math.floor(id) !== id)
                return null;
            throw new errors_1.ObserverNeedsData();
        },
    }
};
//Fetch data needed for specified quereis
//There is a MockObject for every integer id
const observeResolvers = {
    Query: {
        mockById: async (_obj, args, cache, _info) => {
            await uutil.sleep(0);
            const id = Number(args.id);
            await uutil.sleep(Math.min(id, 10)); //Ensure some deterministic delay between 0 and 10 ms
            if (Number.isNaN(id))
                return null; //No such object
            if (Math.floor(id) !== id)
                return null;
            let ret = cache && cache.mockObjects.find((o) => o.id === args.id);
            if (ret === undefined) {
                ret = { id: id.toString(), numericId: id };
                cache.mockObjects.push(ret);
            }
            return ret;
        }
    },
    MockObject: {
        idSquared: async (inObj, _args, _context, _info) => {
            const obj = inObj;
            obj.idSquared = obj.numericId * obj.numericId;
            return obj.idSquared;
        },
        idPlusOne: async (inObj, _args, _context, _info) => {
            const obj = inObj;
            obj.idPlusOne = obj.numericId + 1;
            return obj.idPlusOne;
        }
    }
};
class MockObserver {
    constructor(neverObserve = false) {
        this.neverObserve = neverObserve;
        this.observe = async (possibleQueries) => {
            const cache = { mockObjects: [] };
            if (!this.neverObserve) {
                const waitFor = possibleQueries.map((q) => Promise.resolve(graphql_1.execute(MockObserver.fetchSchema_, q.query, null, cache, q.variables)));
                await Promise.all(waitFor);
            }
            return { context: cache };
        };
    }
    get schema() {
        return MockObserver.schema_;
    }
}
MockObserver.schema_ = graphql_tools_1.makeExecutableSchema({
    typeDefs: schemaStr,
    resolvers: queryCacheResolvers
});
MockObserver.fetchSchema_ = graphql_tools_1.makeExecutableSchema({
    typeDefs: schemaStr,
    resolvers: observeResolvers
});
exports.MockObserver = MockObserver;
exports.default = MockObserver;
registry_1.registerObserver(new MockObserver());
//# sourceMappingURL=MockObserver.js.map