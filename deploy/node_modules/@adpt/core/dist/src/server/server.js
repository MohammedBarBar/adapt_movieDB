"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@adpt/utils");
const ts_custom_error_1 = require("ts-custom-error");
const url_1 = require("url");
exports.$serverLock = Symbol.for("$serverLock");
// Exported for testing only
let serverTypes = [];
function mockServerTypes_(sTypes) {
    const oldTypes = serverTypes;
    if (sTypes != null)
        serverTypes = sTypes;
    return oldTypes;
}
exports.mockServerTypes_ = mockServerTypes_;
function register(serverType) {
    serverTypes.push(serverType);
}
exports.register = register;
async function adaptServer(url, options) {
    let parsed;
    try {
        parsed = new url_1.URL(url);
    }
    catch (err) {
        if (err instanceof TypeError) {
            throw new Error(`Invalid Adapt server url '${url}'`);
        }
        throw err;
    }
    for (const sType of serverTypes) {
        if (sType.urlMatch.test(url)) {
            const server = new sType(parsed, options);
            await server.init();
            return server;
        }
    }
    throw new Error(`Adapt server url '${url}' is not a supported url type.`);
}
exports.adaptServer = adaptServer;
async function withLock(server, f) {
    const lock = await server.lock();
    try {
        return await f(lock);
    }
    finally {
        await server.unlock(lock);
    }
}
exports.withLock = withLock;
class ServerPathExists extends ts_custom_error_1.CustomError {
    constructor(path) {
        super(`Server: path '${path}' already exists`);
        this.path = path;
    }
}
exports.ServerPathExists = ServerPathExists;
utils_1.tagConstructor(ServerPathExists, "adapt");
function isServerPathExists(val) {
    return utils_1.isInstance(val, ServerPathExists, "adapt");
}
exports.isServerPathExists = isServerPathExists;
//# sourceMappingURL=server.js.map