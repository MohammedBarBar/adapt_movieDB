"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const ts_custom_error_1 = require("ts-custom-error");
const internal_error_1 = require("./internal_error");
const index_1 = require("./message/index");
const sleep_1 = require("./sleep");
const debugTaskTime = false;
const defaultTaskGroupOptions = {
    serial: true,
};
const defaultTaskObserverOptions = {
    trivial: false,
};
function parseTaskInfo(jsonString) {
    try {
        const ti = JSON.parse(jsonString);
        if (typeof ti.description !== "string")
            throw new internal_error_1.InternalError(`TaskInfo description invalid`);
        if (typeof ti.trivial !== "boolean")
            throw new internal_error_1.InternalError(`TaskInfo trivial invalid`);
        return ti;
    }
    catch (err) {
        throw new internal_error_1.InternalError(`Unable to parse TaskInfo from task message: ${err.message}`);
    }
}
exports.parseTaskInfo = parseTaskInfo;
function taskInfoToString(ti) {
    return JSON.stringify(ti);
}
exports.taskInfoToString = taskInfoToString;
function createTaskObserver(name, options = {}) {
    return new TaskObserverImpl(name, options);
}
exports.createTaskObserver = createTaskObserver;
class TaskObserverImpl {
    constructor(name, options) {
        this.name = name;
        this.state_ = index_1.TaskState.Created;
        const { logger, description, trivial } = Object.assign({}, defaultTaskObserverOptions, { description: name, logger: new index_1.MessageStreamer(name) }, options);
        this.logger = logger;
        this.description_ = description;
        this.options = {
            logger,
            description,
            trivial,
        };
        this.log(this.state_, taskInfoToString({ description, trivial }));
    }
    get description() {
        return this.description_;
    }
    set description(newDesc) {
        this.log(index_1.TaskStatus.Description, newDesc);
        this.description_ = newDesc;
    }
    get state() {
        return this.state_;
    }
    updateStatus(txt) {
        this.log(index_1.TaskStatus.Status, txt);
    }
    childGroup(options = {}) {
        if (!this.childGroup_) {
            const tgOpts = Object.assign({}, defaultTaskGroupOptions, options);
            this.childGroup_ = new TaskGroupImpl(tgOpts, this.options);
            this.log(index_1.TaskStatus.ChildGroup, JSON.stringify(tgOpts));
        }
        return this.childGroup_;
    }
    started() {
        this.updateState(index_1.TaskState.Started);
    }
    skipped() {
        this.updateState(index_1.TaskState.Skipped);
    }
    complete(p) {
        const done = (val) => {
            this.updateState(index_1.TaskState.Complete);
            // Allow events to fire
            return sleep_1.immediatePromise()
                .then(() => val);
        };
        const fail = (err) => {
            this.failed(err);
            throw err;
        };
        if (lodash_1.default.isFunction(p)) {
            this.started();
            return sleep_1.immediatePromise()
                .then(p)
                .then(done)
                .catch(fail);
        }
        if (p !== undefined) {
            return p
                .then(done)
                .catch(fail);
        }
        this.updateState(index_1.TaskState.Complete);
    }
    failed(err) {
        const msg = lodash_1.default.isError(err) ? err.message : err.toString();
        this.updateState(index_1.TaskState.Failed, msg);
    }
    checkTransition(current, next) {
        if (next === current) {
            throw new TaskObserverStateError(this, current, next);
        }
        let errored = false;
        switch (current) {
            case index_1.TaskState.Complete:
            case index_1.TaskState.Failed:
            case index_1.TaskState.Skipped:
                // These are final states. No transition permitted.
                errored = true;
                break;
            case index_1.TaskState.Started:
                if (next === index_1.TaskState.Created)
                    errored = true;
                break;
            case index_1.TaskState.Created:
                // Must go to Started before Complete
                if (next === index_1.TaskState.Complete)
                    errored = true;
                break;
            default:
                return badState(this, current);
        }
        if (errored)
            throw new TaskObserverStateError(this, current, next);
    }
    log(event, txt) {
        let msg = `[${event}]`;
        if (txt !== undefined)
            msg += `: ${txt}`;
        this.logger.log(index_1.MessageType.task, msg);
    }
    updateState(state, msg) {
        switch (state) {
            case index_1.TaskState.Created:
            case index_1.TaskState.Started:
            case index_1.TaskState.Complete:
            case index_1.TaskState.Failed:
            case index_1.TaskState.Skipped:
                break;
            default:
                return badState(this, state);
        }
        this.checkTransition(this.state_, state);
        if (debugTaskTime) {
            if (state === index_1.TaskState.Started)
                this.startTime = Date.now();
            if (state === index_1.TaskState.Complete && this.startTime) {
                msg = `${Date.now() - this.startTime}ms`;
            }
        }
        this.state_ = state;
        this.log(state, msg);
    }
}
class TaskObserverError extends ts_custom_error_1.CustomError {
    constructor(task, msg) {
        super(`TaskObserver [${task.name}]: ${msg}`);
    }
}
exports.TaskObserverError = TaskObserverError;
class TaskObserverStateError extends TaskObserverError {
    constructor(task, current, next) {
        super(task, `invalid state transition (${current} -> ${next})`);
    }
}
exports.TaskObserverStateError = TaskObserverStateError;
function badState(task, x) {
    throw new TaskObserverError(task, `Invalid state ${x}`);
}
const defaultTaskAddOptions = {
    createOnly: true,
    trivial: false,
};
class TaskGroupImpl {
    constructor(options, taskOptions) {
        this.options = options;
        this.taskOptions = taskOptions;
        this.tasks_ = Object.create(null);
    }
    add(tasks, options = {}) {
        const { createOnly, trivial } = Object.assign({}, defaultTaskAddOptions, options);
        // Pre-flight checks
        if (createOnly) {
            for (const name of Object.keys(tasks)) {
                if (this.tasks_[name]) {
                    throw new Error(`A task with name ${name} already exists`);
                }
            }
        }
        const parentLogger = this.taskOptions.logger;
        for (const name of Object.keys(tasks)) {
            if (this.tasks_[name])
                continue;
            const logger = parentLogger && parentLogger.createChild(name);
            const task = new TaskObserverImpl(name, Object.assign({}, this.taskOptions, { logger, description: tasks[name], trivial }));
            this.tasks_[name] = task;
        }
        return this.tasks_;
    }
    task(name) {
        const obs = this.tasks_[name];
        if (!obs)
            throw new Error(`Task name ${name} not found`);
        return obs;
    }
}
//# sourceMappingURL=task_observer.js.map