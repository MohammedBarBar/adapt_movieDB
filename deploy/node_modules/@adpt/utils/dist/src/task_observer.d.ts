import { CustomError } from "ts-custom-error";
import { MessageLogger, TaskState } from "./message/index";
export interface TaskDefinitions {
    [name: string]: string;
}
export declare type TaskObserversKnown<Names extends string> = {
    [N in Names]: TaskObserver;
};
export interface TaskObserversUnknown {
    [name: string]: TaskObserver | undefined;
}
export declare type TaskObservers<Names extends string> = TaskObserversKnown<Names> & TaskObserversUnknown;
export interface TaskAddOptions {
    createOnly?: boolean;
    trivial?: boolean;
}
export interface TaskGroup {
    add<T extends TaskDefinitions>(tasks: T, options?: TaskAddOptions): TaskObservers<Extract<keyof T, string>>;
    task(name: string): TaskObserver;
}
export interface TaskGroupOptions {
    serial?: boolean;
}
export interface TaskObserver {
    description: string;
    readonly name: string;
    readonly logger: MessageLogger;
    readonly options: TaskObserverOptions;
    readonly state: TaskState;
    updateStatus(txt: string): void;
    childGroup(options?: TaskGroupOptions): TaskGroup;
    started(): void;
    skipped(): void;
    complete(): void;
    complete<T>(p: Promise<T> | (() => T | Promise<T>)): Promise<T>;
    failed(err: string | Error): void;
}
export interface TaskObserverOptions {
    description?: string;
    logger?: MessageLogger;
    trivial?: boolean;
}
export interface TaskInfo {
    description: string;
    trivial: boolean;
}
export declare function parseTaskInfo(jsonString: string): TaskInfo;
export declare function taskInfoToString(ti: TaskInfo): string;
export declare function createTaskObserver(name: string, options?: TaskObserverOptions): TaskObserver;
export declare class TaskObserverError extends CustomError {
    constructor(task: TaskObserver, msg: string);
}
export declare class TaskObserverStateError extends TaskObserverError {
    constructor(task: TaskObserver, current: TaskState, next: TaskState);
}
//# sourceMappingURL=task_observer.d.ts.map