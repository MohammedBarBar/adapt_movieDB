/// <reference types="node" />
import ee2, { EventEmitter2, eventNS, Listener, ListenerFn, OnOptions } from "eventemitter2";
import * as stream from "stream";
export declare type Logger = (arg: any, ...args: any[]) => void;
export declare enum MessageType {
    info = "info",
    warning = "warning",
    error = "error",
    task = "task",
    stdout = "stdout",
    stderr = "stderr"
}
export interface Message {
    type: MessageType;
    timestamp: number;
    from: string;
    content: string;
}
export declare function badMessageType(x: never): never;
export declare function isMessage(val: unknown): val is Message;
export declare function validateMessage(val: unknown): void;
export interface MessageSummary {
    info: number;
    warning: number;
    error: number;
    task: number;
    stdout: number;
    stderr: number;
}
export interface MessageLogger {
    readonly messages: ReadonlyArray<Message>;
    readonly summary: MessageSummary;
    readonly from: string;
    info: Logger;
    warning: Logger;
    error: Logger;
    log: (type: MessageType, arg: any, ...args: any[]) => void;
    append: (this: MessageLogger, toAppend: Message[]) => void;
    message: (this: MessageLogger, msg: Message) => void;
    outStream?: stream.Writable;
    errStream?: stream.Writable;
    readonly isMessageLogger: true;
    createChild: (this: MessageLogger, id: string) => this;
}
export declare function isMessageLogger(val: unknown): val is MessageLogger;
export interface MessageStore {
    readonly messages: ReadonlyArray<Message>;
    store: (this: MessageStore, msg: Message) => void;
    readonly summary: MessageSummary;
}
export declare class LocalStore implements MessageStore {
    readonly messages: Message[];
    readonly summary: MessageSummary;
    store(msg: Message): void;
}
/**
 * MessageEmitter events are namespaced using EventEmitter2.
 * For message-related events, the first component is "message".
 * The remaining components are the task ID.
 *
 * To listen to messages from all tasks:
 *   taskEmitter.on(`message:**`, callback);
 * To listen to all messages for a specific task:
 *   taskEmitter.on(`message:${taskId}`, callback);
 */
export interface MessageEmitter extends EventEmitter2 {
    on(event: ee2.event | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
    on(event: "close", listener: () => void): this | Listener;
    once(event: ee2.event | eventNS, listener: ListenerFn, options?: true | OnOptions): this | Listener;
    once(event: "close", listener: () => void): this | Listener;
    prependListener(event: ee2.event | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
    prependListener(event: "close", listener: () => void): this | Listener;
    prependOnceListener(event: ee2.event | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
    prependOnceListener(event: "close", listener: () => void): this | Listener;
    emit(event: string, msg: Message): boolean;
    listeners(event: string | string[]): MessageListener[];
}
export declare type MessageListener = (msg: Message) => void;
export declare enum TaskState {
    Created = "Created",
    Started = "Started",
    Complete = "Complete",
    Skipped = "Skipped",
    Failed = "Failed"
}
export declare enum TaskStatus {
    Description = "Description",
    Status = "Status",
    ChildGroup = "ChildGroup"
}
export declare type TaskEvent = TaskState | TaskStatus;
export declare const TaskEvent: {
    [x: number]: string;
    Created: TaskState.Created;
    Started: TaskState.Started;
    Complete: TaskState.Complete;
    Skipped: TaskState.Skipped;
    Failed: TaskState.Failed;
    Description: TaskStatus.Description;
    Status: TaskStatus.Status;
    ChildGroup: TaskStatus.ChildGroup;
};
export declare function badTaskEvent(event: never): never;
/**
 * TaskEmitter events are namespaced using EventEmitter2.
 * For task-related events, the first component is "task". The second
 * component is the task event type (see TaskEvent).
 * The remaining components are the task ID.
 *
 * To listen to Created events for all tasks:
 *   taskEmitter.on(`task:Created:**`, callback);
 * To listen to all events for a specific task:
 *   taskEmitter.on(`task:*:${taskId}`, callback);
 * To listen to all events for all tasks:
 *   taskEmitter.on(`task:**`, callback);
 */
export interface TaskEmitter extends EventEmitter2 {
    on(event: ee2.event | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
    on(event: "close", listener: () => void): this | Listener;
    once(event: ee2.event | eventNS, listener: ListenerFn, options?: true | OnOptions): this | Listener;
    once(event: "close", listener: () => void): this | Listener;
    prependListener(event: ee2.event | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
    prependListener(event: "close", listener: () => void): this | Listener;
    prependOnceListener(event: ee2.event | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
    prependOnceListener(event: "close", listener: () => void): this | Listener;
    emit(event: string, msg: Message): boolean;
    listeners(event: string | string[]): TaskListener[];
}
export declare type TaskListener = (event: TaskEvent, status: string | undefined, from: string) => void;
export declare function parseTaskContent(content: string): {
    event: TaskEvent;
    status: string;
};
export interface MessageClient {
    info: MessageEmitter;
    warning: MessageEmitter;
    error: MessageEmitter;
    task: TaskEmitter;
    fromStream?: (this: MessageClient, inputStream: stream.Readable) => void;
    readonly isMessageClient: true;
    readonly outStream?: stream.Writable;
    readonly errStream?: stream.Writable;
}
export declare function isMessageClient(val: unknown): val is MessageClient;
//# sourceMappingURL=common.d.ts.map