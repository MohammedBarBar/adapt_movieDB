"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const type_check_1 = require("../type_check");
var MessageType;
(function (MessageType) {
    MessageType["info"] = "info";
    MessageType["warning"] = "warning";
    MessageType["error"] = "error";
    MessageType["task"] = "task";
    MessageType["stdout"] = "stdout";
    MessageType["stderr"] = "stderr";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
const msgProps = {
    type: "string",
    content: "string",
    from: "string",
    timestamp: "number",
};
function validType(val) {
    switch (val) {
        case "info":
        case "warning":
        case "error":
        case "task":
        case "stdout":
        case "stderr":
            return true;
    }
    return false;
}
function badMessageType(x) {
    throw new Error(`Invalid MessageType: ${x}`);
}
exports.badMessageType = badMessageType;
function isMessage(val) {
    if (!type_check_1.hasValidProps(val, msgProps))
        return false;
    return validType(val.type);
}
exports.isMessage = isMessage;
function validateMessage(val) {
    type_check_1.validateProps("Message", val, msgProps);
    if (!validType(val.type)) {
        throw new type_check_1.ValidationError("Message", `invalid 'type' property value '${val.type}'`);
    }
}
exports.validateMessage = validateMessage;
function isMessageLogger(val) {
    return (val && typeof val === "object" && val.isMessageLogger === true);
}
exports.isMessageLogger = isMessageLogger;
class LocalStore {
    constructor() {
        this.messages = [];
        this.summary = {
            info: 0,
            warning: 0,
            error: 0,
            task: 0,
            stdout: 0,
            stderr: 0,
        };
    }
    store(msg) {
        this.messages.push(msg);
        this.summary[msg.type]++;
    }
}
exports.LocalStore = LocalStore;
var TaskState;
(function (TaskState) {
    TaskState["Created"] = "Created";
    TaskState["Started"] = "Started";
    TaskState["Complete"] = "Complete";
    TaskState["Skipped"] = "Skipped";
    TaskState["Failed"] = "Failed";
})(TaskState = exports.TaskState || (exports.TaskState = {}));
var TaskStatus;
(function (TaskStatus) {
    TaskStatus["Description"] = "Description";
    TaskStatus["Status"] = "Status";
    TaskStatus["ChildGroup"] = "ChildGroup";
})(TaskStatus = exports.TaskStatus || (exports.TaskStatus = {}));
// tslint:disable-next-line:variable-name
exports.TaskEvent = Object.assign({}, TaskStatus, TaskState);
function badTaskEvent(event) {
    throw new Error(`Invalid TaskEvent ${event}`);
}
exports.badTaskEvent = badTaskEvent;
function isTaskEvent(event) {
    const ev = event;
    switch (ev) {
        case exports.TaskEvent.Created:
        case exports.TaskEvent.Started:
        case exports.TaskEvent.Complete:
        case exports.TaskEvent.Skipped:
        case exports.TaskEvent.Failed:
        case exports.TaskEvent.Description:
        case exports.TaskEvent.Status:
        case exports.TaskEvent.ChildGroup:
            return true;
        default:
            return badTaskEvent(ev);
    }
}
/**
 * Task message is one of these two forms:
 *   [Event]
 *   [Event]: Some status message
 */
const taskRegex = /^\[(.+?)\](?::\s*(.+))?$/m;
function parseTaskContent(content) {
    const match = content.match(taskRegex);
    if (!match)
        throw new Error(`Task message not understood: ${content}`);
    const event = match[1];
    if (!isTaskEvent(event))
        throw new Error(`Task event not understood: ${event}`);
    return {
        event,
        status: match[2],
    };
}
exports.parseTaskContent = parseTaskContent;
function isMessageClient(val) {
    return (val && typeof val === "object" && val.isMessageClient === true);
}
exports.isMessageClient = isMessageClient;
//# sourceMappingURL=common.js.map