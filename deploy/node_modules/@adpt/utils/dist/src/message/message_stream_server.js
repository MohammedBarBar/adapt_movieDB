"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const util_1 = require("util");
const common_1 = require("./common");
const intercepted = new Map();
class MessageStreamServer {
    constructor(id, options = {}) {
        this.isMessageLogger = true;
        this.intercepting = false;
        this.end = () => {
            this.outStream.end();
        };
        this.info = (arg, ...args) => {
            this.log(common_1.MessageType.info, arg, ...args);
        };
        this.warning = (arg, ...args) => {
            this.log(common_1.MessageType.warning, arg, ...args);
        };
        this.error = (arg, ...args) => {
            this.log(common_1.MessageType.error, arg, ...args);
        };
        this.log = (type, arg, ...args) => {
            const m = {
                type,
                timestamp: Date.now(),
                from: this.from,
                content: util_1.format(arg, ...args),
            };
            this.message(m);
        };
        this.message = (msg, cb) => {
            this.store.store(msg);
            return this.write(JSON.stringify(msg) + "\n", cb);
        };
        const outStream = options.outStream || (options.parent && options.parent.outStream);
        if (!outStream) {
            throw new Error(`MessageStreamServer: either parent or outStream must be specified`);
        }
        this.outStream = outStream;
        this.store =
            options.store ||
                (options.parent && options.parent.store) ||
                new common_1.LocalStore();
        this.from = options.parent ? `${options.parent.from}:${id}` : id;
        this.write = options.parent ? options.parent.write : outStream.write.bind(outStream);
        if (options.interceptStdio) {
            this.intercept(process.stdout, common_1.MessageType.stdout);
            this.intercept(process.stderr, common_1.MessageType.stderr);
            this.intercepting = true;
        }
    }
    get messages() {
        return this.store.messages;
    }
    get summary() {
        return this.store.summary;
    }
    // FIXME(mark): This function is meant to help with the transition period
    // where some areas of code have not yet been updated to use a
    // MessageLogger. Any use of this function should be replaced with
    // direct use of MessageLogger instead.
    append(toAppend) {
        for (const m of toAppend) {
            this.message(m);
        }
    }
    createChild(id) {
        return new this.constructor(id, {
            parent: this,
            interceptConsole: false,
        });
    }
    stopIntercept() {
        if (!this.intercepting || intercepted.size === 0)
            return;
        intercepted.forEach((origWrite, stream) => {
            stream.write = origWrite;
        });
        intercepted.clear();
        this.intercepting = false;
    }
    intercept(toIntercept, type) {
        if (intercepted.has(toIntercept)) {
            throw new Error(`Only one stdio interceptor can be used at a time`);
        }
        intercepted.set(toIntercept, toIntercept.write);
        // write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;
        // write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;
        toIntercept.write = (chunk, encodingOrCb, cb) => {
            if (lodash_1.isFunction(encodingOrCb))
                cb = encodingOrCb;
            if (!lodash_1.isString(chunk))
                chunk = chunk.toString();
            return this.message({
                type,
                timestamp: Date.now(),
                from: this.from,
                content: chunk,
            }, cb);
        };
    }
}
exports.MessageStreamServer = MessageStreamServer;
//# sourceMappingURL=message_stream_server.js.map