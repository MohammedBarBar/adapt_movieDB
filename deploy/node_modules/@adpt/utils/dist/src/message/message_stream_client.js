"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eventemitter2_1 = tslib_1.__importDefault(require("eventemitter2"));
const readline_1 = tslib_1.__importDefault(require("readline"));
const common_1 = require("./common");
const stringify_1 = require("./stringify");
class MessageStreamClient {
    constructor(options = {}) {
        this.isMessageClient = true;
        this.emitters = {};
        this.inputMessage = (line) => {
            let msg;
            try {
                msg = JSON.parse(line);
                if (!common_1.isMessage(msg))
                    throw new Error(`Failed validation`);
            }
            catch (err) {
                // Turn the message we didn't parse into an error
                msg = {
                    timestamp: Date.now(),
                    type: common_1.MessageType.error,
                    content: `Invalid Message (${err.message}): ${line}`,
                    from: "system.logger",
                };
            }
            const em = this.emitter(msg.type);
            switch (msg.type) {
                case common_1.MessageType.info:
                case common_1.MessageType.error:
                case common_1.MessageType.warning:
                    stringify_1.logToStreams(msg, this.outStream, this.errStream);
                    em.emit(`message:${msg.from}`, msg);
                    break;
                case common_1.MessageType.task:
                    const { event, status } = common_1.parseTaskContent(msg.content);
                    em.emit(`task:${event}:${msg.from}`, event, status, msg.from);
                    break;
                case common_1.MessageType.stdout:
                    if (this.outStream)
                        this.outStream.write(msg.content);
                    break;
                case common_1.MessageType.stderr:
                    if (this.errStream)
                        this.errStream.write(msg.content);
                    break;
                default:
                    return common_1.badMessageType(msg.type);
            }
        };
        if (options.outStream)
            this.outStream = options.outStream;
        if (options.errStream)
            this.errStream = options.errStream;
        if (options.inputStream)
            this.fromStream(options.inputStream);
    }
    fromStream(input) {
        const rl = readline_1.default.createInterface({
            input,
            crlfDelay: Infinity,
        });
        rl.on("line", this.inputMessage);
    }
    get info() { return this.emitter(common_1.MessageType.info); }
    get warning() { return this.emitter(common_1.MessageType.warning); }
    get error() { return this.emitter(common_1.MessageType.error); }
    get task() { return this.emitter(common_1.MessageType.task); }
    emitter(name) {
        let em = this.emitters[name];
        if (!em) {
            em = new eventemitter2_1.default.EventEmitter2({
                wildcard: true,
                delimiter: ":",
            });
            this.emitters[name] = em;
        }
        return em;
    }
}
exports.MessageStreamClient = MessageStreamClient;
//# sourceMappingURL=message_stream_client.js.map