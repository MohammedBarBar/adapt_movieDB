import { PropertiesOfTypeT, TaggedT } from "type-ops";
/**
 * Return an object type that doesn't have keys in ToRemove
 * @public
 */
export declare type Omit<T, ToRemove> = Pick<T, Exclude<keyof T, ToRemove>>;
/**
 * Alias for the more standard name Omit
 * @public
 */
export declare type ExcludeKeys<T, ToRemove> = Omit<T, ToRemove>;
/**
 * Return an object type where if a key appears in the ToRemove object type,
 * it's removed from the returned object type.
 * @public
 */
export declare type ExcludeInterface<T, ToRemove> = ExcludeKeys<T, keyof ToRemove>;
/**
 * Return the keys from T where ALL of the types in union AllOf
 * can be assigned to the associated property type T[K].
 * @remarks
 *
 * Example:
 *   interface Foo {
 *    one: string | number;
 *    two: number;
 *    three: string;
 *    four: object;
 *   }
 *   KeysAssignableToAll<Foo, string | number> === "one"
 * @public
 */
export declare type KeysAssignableToAll<T, AllOf> = {
    [K in keyof T]: [AllOf] extends [T[K]] ? K : never;
}[keyof T];
/**
 * Return the keys from T where ANY one of the types in union AnyOf
 * can be assigned to the associated property type T[K].
 * @remarks
 *
 * Example:
 *   interface Foo {
 *    one: string | number;
 *    two: number;
 *    three: string;
 *    four: object;
 *   }
 *   KeysAssignableToAny<Foo, string | number> === "one" | "two" | "three"
 * @public
 */
export declare type KeysAssignableToAny<T, AnyOf> = {
    [K in keyof T]: [T[K]] extends [AnyOf] ? K : never;
}[keyof T];
/**
 * An opaque type that isn't assignable to any other types except itself and "any"
 * @public
 */
export declare type UniqueType = TaggedT<string, "UniqueType">;
/**
 * Extract only those properties of `T` that have type `any`.
 * @public
 */
export declare type PropertiesOfTypeAny<T extends object> = PropertiesOfTypeT<Required<T>, UniqueType>;
/**
 * Type for a function with a common type of args and a specified return type
 * @public
 */
export declare type FuncType<Args, Ret> = (...args: Args[]) => Ret;
/**
 * Type for a class with a constructor with a common type of args and a
 * specified instance type
 * @public
 */
export declare type ClassType<Args, Ret> = new (...args: Args[]) => Ret;
/**
 * Returns the type of the property `Key` from object type `T`
 * @public
 */
export declare type ExtractType<T, Key extends keyof T> = T extends {
    [Name in Key]: infer Ret;
} ? Ret : T extends {
    [Name in Key]?: infer Ret;
} ? Ret : never;
/**
 * Type of a constructor function that takes any arguments and returns the
 * specified instance type.
 * @public
 */
export declare type Constructor<Inst extends object> = (new (...args: any[]) => Inst);
/**
 * Types that are literals.
 * @public
 */
export declare type Literal = string | number | boolean | undefined | null | void | {};
/**
 * A function to create a tuple, which simultaneously creates both the
 * static type and a runtime array object.
 *
 * @remarks
 * @param args - The elements of the tuple. The type of each element determines
 * the type of each tuple element and, in the case of literals, will be
 * narrowed to the literal unless there is a type assertion on the literal.
 *
 * Example:
 *   const a = tuple("one", 2, true, "3" as string, true as boolean);
 *   // a => ["one", 2, true, "3", true];
 *   // typeof a => ["one", 2, true, string, boolean]
 * @public
 */
export declare const tuple: <T extends Literal[]>(...args: T) => T;
/**
 * Given a tuple, returns a union of all the tuple element types.
 * @public
 */
export declare type TupleToUnion<T extends Literal[]> = T[number];
export declare type FIXME_NeedsProperType = unknown;
/**
 * Type that could either be the input type or a `Promise` for that type.
 * @public
 */
export declare type MaybePromise<T> = T | Promise<T>;
/**
 * Type that could either be the input type or an array of that type.
 * @public
 */
export declare type MaybeArray<T> = T | T[];
/**
 * Type for an object that can have any properties.
 * @public
 */
export interface AnyObject {
    [key: string]: any;
    [key: number]: any;
}
/**
 * Extracts the property names (only string keys) of all methods on an object
 * type.
 * @public
 */
export declare type MethodNames<T> = Extract<{
    [K in keyof T]: Required<T>[K] extends (...args: any[]) => any ? K : never;
}[keyof T], string>;
/**
 * If the input type is a function, returns the return type of the function,
 * otherwise returns `never`.
 * @remarks
 * The difference between this and the standard library `ReturnType` is
 * that there is no restriction on the input type `T`.
 * @public
 */
export declare type ReturnTypeOrNever<T> = T extends (...args: any[]) => any ? ReturnType<T> : never;
//# sourceMappingURL=common_types.d.ts.map