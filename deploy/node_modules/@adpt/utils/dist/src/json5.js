"use strict";
/*
 * Copyright 2020 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const jju_1 = tslib_1.__importDefault(require("jju"));
const json5_1 = tslib_1.__importDefault(require("json5"));
const internal_error_1 = require("./internal_error");
var json5_2 = require("json5");
exports.stringifyJson5 = json5_2.stringify;
/**
 * Read a file from disk and parse as JSON5.
 * @remarks
 * Intended to be a drop-in replacement for fs-extra's readJson. Also adds more
 * helpful error message upon parse failure.
 * @public
 */
async function readJson5(file, options = {}) {
    const contents = (await fs_extra_1.default.readFile(file, options)).toString();
    return parseJson5(contents, options);
}
exports.readJson5 = readJson5;
const defaultParseOptions = {
    prettyError: true,
    throws: true,
};
/**
 * Parse a string with JSON5.
 * @remarks
 * Drop-in replacement for json5.parse and adds the 'throws' option from
 * fs-extra's readJson as well as more helpful error message upon parse
 * failure.
 * @public
 */
function parseJson5(text, options) {
    const inOpts = options === undefined ? {} :
        typeof options === "function" ? { reviver: options } :
            options;
    const { prettyError, reviver, throws } = Object.assign({}, defaultParseOptions, inOpts);
    try {
        return json5_1.default.parse(text, reviver);
    }
    catch (err) {
        if (!throws)
            return null;
        if (prettyError)
            err = prettifySyntaxError(err, text);
        throw err;
    }
}
exports.parseJson5 = parseJson5;
function prettifySyntaxError(err, contents) {
    if (!err || err.name !== "SyntaxError")
        return err;
    const { columnNumber, lineNumber } = err;
    if (columnNumber == null || lineNumber == null)
        return err;
    const lines = contents.split(/\r?\n/g, lineNumber);
    if (lines.length !== lineNumber) {
        throw new internal_error_1.InternalError(`Attempted to display JSON5 error, but wrong number ` +
            `of lines found (expected=${lineNumber} actual=${lines.length}).\n` +
            `Original error: ${err.message}`);
    }
    // Typical error: JSON5: invalid character '=' at 2:6
    err.originalMessage = err.message;
    const errInfo = err.message.replace(/^JSON5: /, "").replace(/ at \d+:\d+/, "");
    const msg = [
        `Invalid JSON5 format: ${errInfo} at line ${lineNumber}, column ${columnNumber}:`,
        lines[lineNumber - 1],
        " ".repeat(columnNumber - 1) + "^-- error here",
    ];
    err.message = msg.join("\n");
    return err;
}
const defaultReadOptions = {
    mustExist: true,
};
const defaultJson5WriterOptions = {
    matchStyle: true,
    style: {
        quote_keys: false,
        indent: 2,
    },
};
/**
 * Make updates to a JSON/JSON5 config file that might be updated by humans.
 * Retains comments and optionally attempts to preserve style already present
 * in the file.
 */
class Json5Writer {
    constructor(filename, options = {}) {
        this.filename = filename;
        this._options = Object.assign({}, defaultJson5WriterOptions, options);
    }
    get text() {
        return this._text;
    }
    get value() {
        return this._value;
    }
    async read(options = {}) {
        const opts = Object.assign({}, defaultReadOptions, options);
        try {
            this._text = (await fs_extra_1.default.readFile(this.filename, opts)).toString();
        }
        catch (err) {
            // If it's ok that the file doesn't exist, return undefined to
            // let the caller know.
            if (err && err.code === "ENOENT" && !opts.mustExist)
                return undefined;
            throw err;
        }
        this._value = jju_1.default.parse(this._text, opts);
        return this.value;
    }
    async update(newValue) {
        const orig = this._text !== undefined ? this._text : "null\n";
        const opts = this._text === undefined || !this._options.matchStyle ?
            this._options.style : undefined;
        const newText = jju_1.default.update(orig, newValue, opts);
        await fs_extra_1.default.writeFile(this.filename, newText);
        this._text = newText;
        this._value = newValue;
    }
}
exports.Json5Writer = Json5Writer;
async function createJson5Writer(filename, options = {}) {
    const writer = new Json5Writer(filename, options);
    await writer.read(options);
    return writer;
}
exports.createJson5Writer = createJson5Writer;
//# sourceMappingURL=json5.js.map