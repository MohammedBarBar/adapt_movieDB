"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const execa_1 = tslib_1.__importDefault(require("execa"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path_1 = tslib_1.__importDefault(require("path"));
function createPackageRegistry(projectDir) {
    return new LazyPackageRegistry(projectDir);
}
exports.createPackageRegistry = createPackageRegistry;
// Length to trim off the file component
const trimRight = "/package.json".length;
class LazyPackageRegistry {
    constructor(projectDir) {
        this.cache = new Map();
        this.findPath = async (pkgName, pkgVersion) => {
            if (!this.pkgsToLoad)
                await this.scanProject();
            const pkgPath = this.cache.get(packageId(pkgName, pkgVersion));
            if (pkgPath !== undefined)
                return pkgPath;
            return this.loadPackage(pkgName, pkgVersion);
        };
        this.projectDir = path_1.default.resolve(projectDir);
        this.nodeModulesDir = path_1.default.join(this.projectDir, "node_modules");
        if (!fs_extra_1.default.pathExistsSync(this.nodeModulesDir)) {
            throw new Error(`Project directory ${this.projectDir} does not ` +
                `contain a node_modules folder`);
        }
    }
    async scanProject() {
        const pInfo = await this.projectInfo();
        this.cache.set(packageId(pInfo.name, pInfo.version), this.projectDir);
        await this.scanPackages();
    }
    async scanPackages() {
        const files = await findFiles(this.nodeModulesDir, "package.json");
        const dirs = files.map((f) => f.slice(0, -trimRight));
        // Trim off the root node_modules dir
        const trimLeft = this.nodeModulesDir.length + 1;
        const stripped = dirs.map((f) => f.slice(trimLeft));
        const names = stripped.map((s) => lodash_1.last(s.split("/node_modules/")));
        const packages = new Map();
        names.map((name, idx) => name && addPackage(name, dirs[idx]));
        this.pkgsToLoad = packages;
        return packages;
        function addPackage(pkgName, pkgPath) {
            let paths = packages.get(pkgName);
            if (!paths) {
                paths = [];
                packages.set(pkgName, paths);
            }
            paths.push(pkgPath);
        }
    }
    async projectInfo() {
        const pjFile = path_1.default.join(this.projectDir, "package.json");
        let err = "unknown error";
        try {
            const pkgJ = await fs_extra_1.default.readJSON(pjFile);
            if (!lodash_1.isObject(pkgJ))
                err = `Invalid package.json file`;
            else if (!lodash_1.isString(pkgJ.name))
                err = `Invalid package name`;
            else if (!lodash_1.isString(pkgJ.version))
                err = `Invalid version`;
            else
                return pkgJ;
        }
        catch (e) {
            err = `Unable to open package.json file: ${e.message}`;
        }
        throw new Error(`Error reading project file ${pjFile}: ${err}`);
    }
    async loadPackage(pkgName, pkgVersion) {
        if (this.pkgsToLoad == null) {
            throw new Error(`Internal error: package registry packages is null`);
        }
        const pathList = this.pkgsToLoad.get(pkgName);
        if (pathList == null)
            return undefined;
        while (true) {
            const pkgPath = pathList.pop();
            if (pathList.length === 0) {
                // All entries for this pkgName have been loaded
                this.pkgsToLoad.delete(pkgName);
            }
            if (!pkgPath)
                break;
            const pkgJsonPath = path_1.default.join(pkgPath, "package.json");
            const pkgJson = await fs_extra_1.default.readJSON(pkgJsonPath);
            if (pkgJson.name !== pkgName) {
                throw new Error(`Package name in path doesn't match name in package.json ` +
                    `(${pkgJson.name} ${pkgJsonPath})`);
            }
            if (typeof pkgJson.version !== "string" || pkgJson.version.length === 0) {
                // Should just be a warning?
                throw new Error(`Invalid or missing version field in ${pkgJsonPath}`);
            }
            this.cache.set(packageId(pkgName, pkgJson.version), pkgPath);
            if (pkgJson.version === pkgVersion)
                return pkgPath;
        }
        return undefined;
    }
}
exports.LazyPackageRegistry = LazyPackageRegistry;
function packageId(pkgName, pkgVersion) {
    return `${pkgName}@${pkgVersion}`;
}
async function findFiles(rootDir, filename) {
    try {
        const { stdout: fileList } = await execa_1.default("find", [rootDir, "-name", filename], { all: true });
        return fileList.split("\n");
    }
    catch (e) {
        if (e.all)
            e.message += "\n" + e.all;
        throw e;
    }
}
//# sourceMappingURL=package_registry.js.map