"use strict";
/*
 * Copyright 2019-2020 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const console_1 = require("console");
const execa_1 = tslib_1.__importDefault(require("execa"));
const fs_extra_1 = require("fs-extra");
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const internal_error_1 = require("./internal_error");
const paths_1 = require("./paths");
exports.buildDir = path_1.default.join(paths_1.repoRootDir, "build");
exports.buildLogDir = getBuildLogDir();
exports.buildLogEnabled = !!exports.buildLogDir;
let warned = false;
function ciReportEnabled(level = 1) {
    const enabledEnv = process.env.ADAPT_CI_REPORT;
    if (enabledEnv == null)
        return false;
    const enabled = Number(enabledEnv);
    if (isNaN(enabled) || enabled < 0 || enabled > 7 || Math.trunc(enabled) !== enabled) {
        if (!warned) {
            // tslint:disable-next-line: no-console
            console.error(`WARNING: Environment variable ADAPT_CI_REPORT ` +
                `set to invalid value ${enabledEnv}`);
            warned = true;
        }
    }
    return enabled >= level;
}
exports.ciReportEnabled = ciReportEnabled;
function pad(num, len = 2) {
    return num.toString().padStart(len, "0");
}
function ciCreateLogfileName(prefix) {
    if (!exports.buildLogDir)
        return undefined;
    const d = new Date();
    const dateStrings = [d.getMonth() + 1, d.getDate(), d.getHours(),
        d.getMinutes(), d.getSeconds()].map((n) => pad(n));
    const filename = util_1.format("%s-%d%s%s-%s%s%s.%s.log", prefix, d.getFullYear(), ...dateStrings, pad(d.getMilliseconds(), 3));
    return path_1.default.join(exports.buildLogDir, filename);
}
exports.ciCreateLogfileName = ciCreateLogfileName;
function ciCreateLogfileStream(prefix) {
    let i = 0;
    while (true) {
        try {
            const logfile = ciCreateLogfileName(prefix);
            if (!logfile)
                return undefined;
            return fs_extra_1.createWriteStream(logfile, { flags: "wx" });
        }
        catch (err) {
            // Retry if the file exists. Should (eventually) get a new timestamp.
            if (err.code !== "EEXIST")
                throw err;
            if (++i >= 1000) {
                // tslint:disable-next-line: no-console
                console.warn(`WARNING: Unable to create logfile stream for CI (prefix=${prefix})`, err);
                return undefined;
            }
        }
    }
}
exports.ciCreateLogfileStream = ciCreateLogfileStream;
const noop = () => { };
const defaultCiLoggerOptions = {
    lazyCreate: true,
};
class CiLogger {
    constructor(prefix, options = {}) {
        // Lazy create version. Gets replaced on first call.
        this.log = (...args) => {
            if (!this.console)
                this.console = this.create();
            this.console.log(timestamp(), ...args);
        };
        this.logps = () => {
            const ret = execa_1.default.commandSync("ps auxf");
            this.log("PS", ret.stdout);
        };
        const opts = Object.assign({}, defaultCiLoggerOptions, options);
        this.prefix = prefix;
        if (!exports.buildLogEnabled) {
            this.log = noop;
            this.logps = noop;
            return;
        }
        if (!opts.lazyCreate)
            this.create();
    }
    close() {
        if (!this.logStream)
            return;
        this.logStream.close();
        this.logStream = undefined;
    }
    create() {
        this.logStream = ciCreateLogfileStream(this.prefix);
        if (!this.logStream)
            throw new internal_error_1.InternalError(`Did not create logStream for ${this.prefix}`);
        return new console_1.Console(this.logStream);
    }
}
function ciMaybeCreateLogger(prefix, options = {}) {
    if (!exports.buildLogEnabled)
        return undefined;
    return ciCreateLogger(prefix, options);
}
exports.ciMaybeCreateLogger = ciMaybeCreateLogger;
function ciCreateLogger(prefix, options = {}) {
    return new CiLogger(prefix, options);
}
exports.ciCreateLogger = ciCreateLogger;
function timestamp() {
    const d = new Date();
    const dateStrings = [d.getMonth() + 1, d.getDate(), d.getHours(),
        d.getMinutes(), d.getSeconds()].map((n) => pad(n));
    return util_1.format("%d-%s-%s %s:%s:%s.%s", d.getFullYear(), ...dateStrings, pad(d.getMilliseconds(), 3));
}
function getBuildLogDir() {
    let dir = process.env.ADAPT_BUILD_LOGDIR;
    if (!dir)
        return undefined;
    dir = path_1.default.resolve(paths_1.repoRootDir, dir);
    if (!fs_extra_1.existsSync(dir))
        return undefined;
    return dir;
}
//# sourceMappingURL=ci_report.js.map