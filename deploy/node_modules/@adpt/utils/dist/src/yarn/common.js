"use strict";
/*
 * Copyright 2019-2020 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const decamelize_1 = tslib_1.__importDefault(require("decamelize"));
const execa_1 = tslib_1.__importDefault(require("execa"));
const npm_run_path_1 = tslib_1.__importDefault(require("npm-run-path"));
const ci_report_1 = require("../ci_report");
const noArgOptions = [
    "noProgress",
];
exports.commonDefaults = {
    loglevel: "normal",
    pipeOutput: false,
    noProgress: true,
};
const npmPath = npm_run_path_1.default({ cwd: __dirname });
/**
 * NOTE: This function is purposely NOT async.
 * The childProc object that execa returns gives the caller a lot of flexibility
 * in how to consume the results, especially including consuming the
 * output streams in real time, without waiting for the target process to exit.
 * So we take care to pass exactly that object back, NOT a promise to that object.
 */
function run(action, options, args) {
    // tslint:disable-next-line:prefer-const
    let _a = Object.assign({}, exports.commonDefaults, options), { boolNoArgOptions = [], loglevel, pipeOutput } = _a, opts = tslib_1.__rest(_a, ["boolNoArgOptions", "loglevel", "pipeOutput"]);
    boolNoArgOptions.push(...noArgOptions);
    const finalOpts = optionsBoolToUndef(opts, boolNoArgOptions);
    const finalArgs = [action];
    if (loglevel === "silent")
        finalArgs.push("--silent");
    if (loglevel === "verbose")
        finalArgs.push("--verbose");
    for (const opt of Object.keys(finalOpts)) {
        const flag = "--" + decamelize_1.default(opt, "-");
        finalArgs.push(flag);
        const val = finalOpts[opt];
        if (val !== undefined)
            finalArgs.push(val.toString());
    }
    if (args)
        finalArgs.push(...args);
    const env = { PATH: npmPath };
    const childProc = execa_1.default("yarn", finalArgs, {
        all: true,
        env,
        stripFinalNewline: false,
    });
    const logStop = logStart(childProc.pid, finalArgs);
    if (pipeOutput) {
        childProc.stdout.pipe(process.stdout);
        childProc.stderr.pipe(process.stdout);
    }
    // Make the error message slightly more helpful. But if we want to
    // return the original childProc object, we have to do a little
    // extra work to insert our translation into the promise chain rather
    // than just adding a .catch handler.
    const translateError = (err) => {
        err.message = `yarn ${action} failed: ${err.message}\n${err.all}`;
        return Promise.reject(err);
    };
    insertCatch(childProc, translateError);
    // This "then" creates a separate chain and that's ok
    childProc.then((child) => logStop(child.all), (err) => logStop(err.all || err.message || err));
    return childProc;
}
exports.run = run;
function insertCatch(childProc, catcher) {
    const origCatch = childProc.catch;
    const origThen = childProc.then;
    childProc.then = (onFulfilled, onRejected) => {
        try {
            return origThen(onFulfilled, catcher).catch(onRejected);
        }
        catch (err) {
            return catcher(err);
        }
    };
    childProc.catch = (onRejected) => {
        try {
            return origCatch(catcher).catch(onRejected);
        }
        catch (err) {
            return catcher(err);
        }
    };
}
function optionsBoolToUndef(options, keys) {
    const ret = Object.assign({}, options);
    for (const k of keys) {
        if (ret[k])
            ret[k] = undefined;
        else
            delete ret[k];
    }
    return ret;
}
function parseJsonMessages(output, typeFilter) {
    const lines = output.split(/\r?\n/g);
    let objs = lines.map((l) => {
        try {
            return JSON.parse(l);
        }
        catch (e) {
            return { type: "MessageError", data: e.message };
        }
    });
    if (typeFilter)
        objs = objs.filter((o) => o != null && o.type === typeFilter);
    return objs;
}
exports.parseJsonMessages = parseJsonMessages;
function logStart(pid, args) {
    const logger = ci_report_1.ciMaybeCreateLogger(`yarn-${pid}`);
    if (!logger)
        return () => { };
    const argstr = `yarn ${args.join(" ")}`;
    logger.log(`RUN ${argstr}`);
    logger.logps();
    return (output) => {
        logger.log(`DONE ${argstr}`);
        logger.log(`OUTPUT`, output);
        logger.close();
    };
}
//# sourceMappingURL=common.js.map