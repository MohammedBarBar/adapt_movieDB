/// <reference types="node" />
import { AdaptElementOrNull } from '@adpt/core';
import { FIXME_NeedsProperType } from '@adpt/utils';
import { WithChildren } from '@adpt/core';

export declare namespace action {
/**
   * Type guard for {@link action.ShouldActDetail}.
   * @public
   */
  export declare function isShouldActDetail(val: any): val is ShouldActDetail;/**
   * Transforms a {@link action.ShouldAct} into an {@link action.ShouldActDetail}.
   * @internal
   */
  export declare function toDetail(val: ShouldAct): {
      act: boolean;
      detail: string;
  };/**
   * Type guard for Action FinalDomElements.
   * @internal
   */
  export declare function isActionFinalElement(val: any): val is FinalDomElement;/**
   * Returns the component instance for an {@link action.Action} component.
   * @internal
   */
  export declare function getActionInstance(el: FinalDomElement): Action | null;/**
   * Detailed information on why an action should be taken.
   * @public
   */
  export declare interface ShouldActDetail {
      /**
       * True if the action should be performed.
       */
      act: boolean;
      /**
       * Explanation of why the action should be performed.
       */
      detail: string;
  }/**
   * Return type for {@link action.Action.shouldAct} that describes whether an
   * action should be taken and why.
   * @public
   */
  export declare type ShouldAct = false | ShouldActDetail;/**
   * Helper information for an {@link action.Action} component.
   * @public
   */
  export declare interface ActionContext {
      /** Various pieces of data about the current element and build cycle */
      buildData: BuildData;
      /** A location to put files that need to be persisted as state */
      dataDir: string;
      /** Interface to use for logging messages.  Prefer to using stderr or stdout */
      logger: MessageLogger;
  }/**
   * Component that can be inherited to perform actions during deploy
   *
   * @public
   */
  export declare class Action<P extends object = {}, S extends object = {}> extends PrimitiveComponent<P, S> {
      /**
       * Calculates whether or not any action is needed based on state/props/observation
       *
       * @returns false if no action needed, `{ act: true, detail: <user-facing description of action> }`.
       */
      shouldAct(_op: ChangeType, _ctx: ActionContext): ShouldAct | Promise<ShouldAct>;
      action(_op: ChangeType, _ctx: ActionContext): void | Promise<void>;
  }/**
   * Properties for the {@link action.Command | Command} component.
   * @public
   */
  export declare interface CommandProps {
      shouldRun?: string[];
      shouldDelete?: string[];
      run: string[];
      delete?: string[];
  }/**
   * Primitive component that can be used to interact with commands via the
   * OS shell to implement actions in Adapt.
   * @public
   */
  export declare class Command extends Action<CommandProps> {
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldActDetail>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
  }/**
   * Type guard for {@link action.ShouldActDetail}.
   * @public
   */
  export declare function isShouldActDetail(val: any): val is ShouldActDetail;/**
   * Transforms a {@link action.ShouldAct} into an {@link action.ShouldActDetail}.
   * @internal
   */
  export declare function toDetail(val: ShouldAct): {
      act: boolean;
      detail: string;
  };/**
   * Type guard for Action FinalDomElements.
   * @internal
   */
  export declare function isActionFinalElement(val: any): val is FinalDomElement;/**
   * Returns the component instance for an {@link action.Action} component.
   * @internal
   */
  export declare function getActionInstance(el: FinalDomElement): Action | null;/**
   * Detailed information on why an action should be taken.
   * @public
   */
  export declare interface ShouldActDetail {
      /**
       * True if the action should be performed.
       */
      act: boolean;
      /**
       * Explanation of why the action should be performed.
       */
      detail: string;
  }/**
   * Return type for {@link action.Action.shouldAct} that describes whether an
   * action should be taken and why.
   * @public
   */
  export declare type ShouldAct = false | ShouldActDetail;/**
   * Helper information for an {@link action.Action} component.
   * @public
   */
  export declare interface ActionContext {
      /** Various pieces of data about the current element and build cycle */
      buildData: BuildData;
      /** A location to put files that need to be persisted as state */
      dataDir: string;
      /** Interface to use for logging messages.  Prefer to using stderr or stdout */
      logger: MessageLogger;
  }/**
   * Component that can be inherited to perform actions during deploy
   *
   * @public
   */
  export declare class Action<P extends object = {}, S extends object = {}> extends PrimitiveComponent<P, S> {
      /**
       * Calculates whether or not any action is needed based on state/props/observation
       *
       * @returns false if no action needed, `{ act: true, detail: <user-facing description of action> }`.
       */
      shouldAct(_op: ChangeType, _ctx: ActionContext): ShouldAct | Promise<ShouldAct>;
      action(_op: ChangeType, _ctx: ActionContext): void | Promise<void>;
  }/**
   * Properties for the {@link action.Command | Command} component.
   * @public
   */
  export declare interface CommandProps {
      shouldRun?: string[];
      shouldDelete?: string[];
      run: string[];
      delete?: string[];
  }/**
   * Primitive component that can be used to interact with commands via the
   * OS shell to implement actions in Adapt.
   * @public
   */
  export declare class Command extends Action<CommandProps> {
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldActDetail>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
  }/**
   * Type guard for {@link action.ShouldActDetail}.
   * @public
   */
  export declare function isShouldActDetail(val: any): val is ShouldActDetail;/**
   * Transforms a {@link action.ShouldAct} into an {@link action.ShouldActDetail}.
   * @internal
   */
  export declare function toDetail(val: ShouldAct): {
      act: boolean;
      detail: string;
  };/**
   * Type guard for Action FinalDomElements.
   * @internal
   */
  export declare function isActionFinalElement(val: any): val is FinalDomElement;/**
   * Returns the component instance for an {@link action.Action} component.
   * @internal
   */
  export declare function getActionInstance(el: FinalDomElement): Action | null;/**
   * Detailed information on why an action should be taken.
   * @public
   */
  export declare interface ShouldActDetail {
      /**
       * True if the action should be performed.
       */
      act: boolean;
      /**
       * Explanation of why the action should be performed.
       */
      detail: string;
  }/**
   * Return type for {@link action.Action.shouldAct} that describes whether an
   * action should be taken and why.
   * @public
   */
  export declare type ShouldAct = false | ShouldActDetail;/**
   * Helper information for an {@link action.Action} component.
   * @public
   */
  export declare interface ActionContext {
      /** Various pieces of data about the current element and build cycle */
      buildData: BuildData;
      /** A location to put files that need to be persisted as state */
      dataDir: string;
      /** Interface to use for logging messages.  Prefer to using stderr or stdout */
      logger: MessageLogger;
  }/**
   * Component that can be inherited to perform actions during deploy
   *
   * @public
   */
  export declare class Action<P extends object = {}, S extends object = {}> extends PrimitiveComponent<P, S> {
      /**
       * Calculates whether or not any action is needed based on state/props/observation
       *
       * @returns false if no action needed, `{ act: true, detail: <user-facing description of action> }`.
       */
      shouldAct(_op: ChangeType, _ctx: ActionContext): ShouldAct | Promise<ShouldAct>;
      action(_op: ChangeType, _ctx: ActionContext): void | Promise<void>;
  }/**
   * Properties for the {@link action.Command | Command} component.
   * @public
   */
  export declare interface CommandProps {
      shouldRun?: string[];
      shouldDelete?: string[];
      run: string[];
      delete?: string[];
  }/**
   * Primitive component that can be used to interact with commands via the
   * OS shell to implement actions in Adapt.
   * @public
   */
  export declare class Command extends Action<CommandProps> {
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldActDetail>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
  }
}

export declare namespace aws {
/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: Adapt.PropsType<W> & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: Adapt.PropsType<W> & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: Adapt.PropsType<W> & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: Adapt.PropsType<W> & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: Adapt.PropsType<W> & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: Adapt.PropsType<W> & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.AdaptElement<Adapt.AnyProps>;
}

/**
 * A command to be used when creating a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type Command = string | string[];

/**
 * Abstract element to represent a computational resource
 *
 * @beta
 */
export declare abstract class Compute extends Component<ComputeProps, {}> {
}

/**
 * Props for a {@link Compute} element
 *
 * @beta
 */
export declare interface ComputeProps extends WithChildren {
    name?: string;
    ip?: string;
}

/**
 * Config for {@link ContainerStatus}
 * @public
 */
export declare interface Config {
    Hostname: string;
    Domainname: string;
    User: string;
    AttachStdin: boolean;
    AttachStdout: boolean;
    AttachStderr: boolean;
    Tty: boolean;
    OpenStdin: boolean;
    StdinOnce: boolean;
    Env: string[];
    Cmd: string[];
    ArgsEscaped: boolean;
    Image: string;
    Volumes: FIXME_NeedsProperType;
    WorkingDir: string;
    Entrypoint: FIXME_NeedsProperType;
    OnBuild: FIXME_NeedsProperType;
    Labels: ContainerLabels;
    StopSignal: FIXME_NeedsProperType;
    ExposedPorts: null | {
        [port: string]: {};
    };
}

/**
 * Components that provide a service, such as a database service or API
 * service, can implement this interface in order to supply all the information
 * required to connect to the service.
 *
 * @remarks
 * Currently, the only method supported for providing connection information
 * is via environment variables. However, additional formats for providing
 * connection information will be added as needs arise.
 * @public
 */
export declare interface ConnectToInstance {
    /**
     * Supplies the set of environment variables that have all the information
     * needed for a consumer of a service to connect to the provider.
     *
     * @param scope - Scope for which connection information is desired
     * @returns Environment with connection information, undefined if info not yet ready.
     *
     * @remarks
     * This may include information like network hostname(s), port(s),
     * credentials, namespace, or any other service-specific information.
     *
     * In cases where the service has not been deployed yet or the
     * connection information is not yet available for any reason, the
     * method will return `undefined`.
     *
     * If a scope for which there will never be connection information is
     * requested, this method should throw an appropriate error.  For example
     * if `NetworkScope.external` is requested for a service only reachable
     * from within a cluster, this method should throw.
     *
     * Providers are discouraged from using environment variable names
     * that are too generic or are likely to conflict with other environment
     * variables that may already be in use. For example, avoid names like
     * `HOST` and `USERNAME`. Instead, use names that are likely to be
     * unique to the type of service so that a consumer can
     * use more than one type of service without causing naming conflicts.
     *
     * Providers are encouraged to use environment variable names that are
     * typically used by consumers of the service. For example, the provider
     * of a Postgres database service should use the names `PGHOST` and
     * `PGUSER`, which are defined in the Postgres documentation and
     * are typically supported by most Postgres database clients.
     *
     * Providers should never return partial information. Return `undefined`
     * until all required connection information is available.
     */
    connectEnv(scope?: NetworkScope): Environment | undefined;
}

/**
 * Abstract component representing a container.
 * @public
 */
export declare abstract class Container extends PrimitiveComponent<ContainerProps> {
    static defaultProps: {
        dockerHost: string;
        autoRemove: boolean;
        ports: never[];
        stdinOpen: boolean;
        tty: boolean;
        portBindings: {};
        environment: {};
        links: {};
        imagePullPolicy: string;
    };
    static displayName: string;
}

/**
 * Labels for a {@link Container}
 * @public
 */
export declare interface ContainerLabels {
    [name: string]: string;
}

/**
 * Network for {@link ContainerStatus}
 * @public
 */
export declare interface ContainerNetwork {
    IPAMConfig: FIXME_NeedsProperType;
    Links: FIXME_NeedsProperType;
    Aliases: FIXME_NeedsProperType;
    NetworkID: string;
    EndpointID: string;
    Gateway: string;
    IPAddress: string;
    IPPrefixLen: number;
    IPv6Gateway: string;
    GlobalIPv6Address: string;
    GlobalIPv6PrefixLen: number;
    MacAddress: string;
    DriverOpts: FIXME_NeedsProperType;
}

/**
 * NetworkSettings for {@link ContainerStatus}
 * @public
 */
export declare interface ContainerNetworkSettings {
    Bridge: FIXME_NeedsProperType;
    SandboxID: string;
    HairpinMode: boolean;
    LinkLocalIPv6Address: string;
    LinkLocalIPv6PrefixLen: number;
    Ports: FIXME_NeedsProperType;
    SandboxKey: string;
    SecondaryIPAddresses: FIXME_NeedsProperType;
    SecondaryIPv6Addresses: FIXME_NeedsProperType;
    EndpointID: string;
    Gateway: string;
    GlobalIPv6Address: string;
    GlobalIPv6PrefixLen: number;
    IPAddress: string;
    IPPrefixLen: number;
    IPv6Gateway: string;
    MacAddress: string;
    Networks: {
        [name: string]: ContainerNetwork;
    };
}

/**
 * Props for the {@link Container} component.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface ContainerProps {
    name: string;
    dockerHost: string;
    image: ImageId;
    autoRemove?: boolean;
    ports?: PortDescription[];
    stdinOpen?: boolean;
    stopSignal?: string;
    tty?: boolean;
    command?: Command;
    portBindings?: PortBinding;
    environment?: Environment;
    links?: Links;
    entrypoint?: Command;
    /**
     * The behavior to apply when the container exits.
     * @remarks
     * See {@link RestartPolicy} and {@link RestartPolicyName} for the
     * possible values and corresponding behavior.
     * @defaultValue The default is `{ name: "Never" }`, which does not
     * restart the container.
     */
    restartPolicy?: RestartPolicy;
    workingDir?: string;
    imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
}

/**
 * State information for a {@link Container}.
 * @public
 */
export declare interface ContainerState {
    Status: string;
    Running: boolean;
    Paused: boolean;
    Restarting: boolean;
    OOMKilled: boolean;
    Dead: boolean;
    Pid: number;
    ExitCode: number;
    Error: string;
    StartedAt: string;
    FinishedAt: string;
}

/**
 * Status of a {@link Container}.
 * @public
 */
export declare interface ContainerStatus {
    Id: string;
    Created: string;
    Path: string;
    Args: string[];
    State: ContainerState;
    Image: string;
    ResolvConfPath: string;
    HostnamePath: string;
    HostsPath: string;
    Node: FIXME_NeedsProperType;
    Name: string;
    RestartCount: number;
    Driver: string;
    MountLabel: string;
    ProcessLabel: string;
    AppArmorProfile: string;
    ExecIDs: string;
    HostConfig: HostConfigStatus;
    GraphDriver: FIXME_NeedsProperType;
    SizeRw: number;
    SizeRootFs: number;
    Mounts: MountStatus[];
    Config: Config;
    NetworkSettings: ContainerNetworkSettings;
}

export declare namespace docker {
/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageInfo | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       * @remarks
       * If `newTag` is provided, the image will have that tag in the
       * given registry. Otherwise, the image's existing tag will be used.
       * It is an error in that case if there is no tag associated with the
       * `latestImage` image.
       *
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageInfo} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo(registryUrl: string, newTag?: NameTagString): MaybePromise<ImageInfo | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageInfo | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageInfo | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string | undefined;
      };
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: ImageInfo;
      imagePropsJson?: string;
      prevUniqueTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): ImageInfo | undefined;
      pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
      latestImage(): ImageInfo | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected readonly imagePropsJson: string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * URL or string for the registry where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryUrl will be used for both push and pull
       *
       * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryUrl: string | DockerSplitRegistryInfo;
      /**
       * Tag to use for the image in the registry.
       * @remarks
       * If omitted, the tag from the source is used.  The tag should not
       * include the registry hostname/port prefix.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageInfo | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageInfo | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueTag (or prevUniqeTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueTag, then prevUniqueTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: string;
      internal: string;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;
}

/**
 * Represents a Docker Host
 *
 * @alpha
 */
export declare class DockerHost extends Component<DockerHostProps> {
    build(): AdaptElementOrNull;
}

/**
 * Props for {@link DockerHostProps}
 *
 * @alpha
 */
export declare interface DockerHostProps {
    dockerHost?: string;
}

/**
 * A set of environment variables for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type Environment = EnvPair[] | EnvSimple;

/**
 * A single environment variable for a {@link Container}, expressed as an
 * object with `name` and `value` properties.
 *
 * @public
 */
export declare interface EnvPair {
    name: string;
    value: string;
}

/**
 * A set of environment variables for a {@link Container}, expressed as an
 * array of objects with `name` and `value` properties.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type EnvPairs = EnvPair[];

/**
 * A set of environment variables for a {@link Container}, expressed as a
 * single object with keys and associated values.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface EnvSimple {
    [key: string]: string;
}

/** @alpha */
export declare interface ExtendedHandle extends Handle {
    [method: string]: any;
}

/** @alpha */
export declare function extendedHandle(): Handle<import("@adpt/core").GenericInstance & import("@adpt/core").GenericInstanceMethods>;

/**
 * Represents an remote Docker Host
 *
 * @alpha
 */
export declare class ExternalDockerHost extends PrimitiveComponent<ExternalDockerHostProps> {
    updateState(state: any): void;
}

/**
 * Props for {@link ExternalDockerHost}
 *
 * @alpha
 */
export declare interface ExternalDockerHostProps {
    dockerHost: string;
}

/**
 * Formats an {@link Environment} for printing in human-readable format.
 *
 * @param env - The environment to be printed.
 * @returns - A string representation of the environment for use in logging
 * or debugging.
 *
 * @public
 */
export declare function formatEnvVars(env: Environment): string;

export declare namespace gcloud {
/**
   * Temporary adapter to allow handle for image
   *
   * @beta
   */
  export declare function CloudRunAdapter(propsIn: CloudRunAdapterProps): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for the {@link gcloud.CloudRun} component
   *
   * @public
   */
  export declare interface CloudRunProps {
      /** Environment for the container in the deployment */
      env?: Environment;
      /** Arguments for the container entrypoint */
      args?: string[];
      /** Image from which to start the container */
      image: string;
      /**
       * Name of the Cloud Run service in gcloud
       *
       * @remarks
       * This is the absolute name of the service to use.  If not specified
       * Adapt will automatically generate a name for the service.
       */
      serviceName?: string;
      /** Region in which to create the cloud run deployment */
      region: string;
      /**
       * Port on which the container will listen
       *
       * @remarks
       * The container must listen on this port.  There is no port mapping
       * in CloudRun.  However, this will set the `PORT` environment variable
       * for the container, and so the container can listen on this port
       * to get the effect of port mapping.
       */
      port: number;
      /**
       * Percentage of traffic for the latest revision of the deployment
       *
       * @remarks
       *
       * CloudRun can send traffic to multiple revisions of the same
       * service.  Every deploy to cloud run creates a new revision. After
       * health checks pass, the latest container will receive trafficPct/100
       * of the total traffic.  Set this to 100 to ensure that the
       * latest deployment gets all the traffic once up and running, set it to 0
       * for the latest version to get no traffic.
       *
       * NOTE: This value ranges from 0 to 100, not 0.0 to 1.0
       */
      trafficPct: number;
      /**
       * CPU resources that can be consumed by this CloudRun deployment
       *
       * @remarks
       * This is a Kubernetes style cpu specification string.
       * 1 is 1 cpu, 2 is 2 cpus, 100m is 100minutes of CPU allocation, etc.
       *
       * Please look at Google's Cloud Run documentation for more information and any
       * restrictions vs. Kubernetes.
       */
      cpu: string | number;
      /**
       * Memory allocated to this deployment
       *
       * @remarks
       * This is a Kubernetes style string.  128Mi is 128 Mibibytes, etc.
       *
       * Please look at Google's Cloud Run documentation for more information
       * and any restrictions vs. Kubernetes.
       */
      memory: string | number;
      /**
       * Allow public access to this service
       *
       * @remarks
       * If set to `true`, the service will be public.  Otherwise,
       * authentication will be required to access the service from outside
       * the project.
       */
      allowUnauthenticated: boolean;
      /**
       * Specify a gcloud configuration to use
       *
       * @remarks
       * For unit test use only, functionality may change or disappear.
       *
       * @internal
       */
      configuration?: string;
  }/**
   * Primitive Component for GCP Cloud Run deployments
   * @public
   */
  export declare class CloudRun extends Action<CloudRunProps> {
      static defaultProps: {
          trafficPct: number;
          memory: string;
          cpu: number;
          allowUnauthenticated: boolean;
      };
      config_: Config;
      constructor(props: CloudRunProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus) => Promise<true | Adapt.Waiting>;
      private mountedElement;
      private config;
  }/**
   * Exported for testing only
   *
   * @internal
   */
  const makeCloudRunName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Props for the {@link gcloud.CloudRunAdapter} component
   *
   * @beta
   */
  export declare type CloudRunAdapterProps = SFCDeclProps<Omit<CloudRunProps, "image"> & {
      image: Handle;
      registryUrl: string;
  } & Partial<BuiltinProps>, typeof CloudRun.defaultProps>;
}

/** @alpha */
export declare type Handles = HandlesCreate & HandlesIndex;

/** @alpha */
export declare function handles(): Handles;

/** @alpha */
export declare interface HandlesCreate {
    create: HandlesIndex;
}

/** @alpha */
export declare interface HandlesIndex {
    [hand: string]: ExtendedHandle;
}

/**
 * HostConfig for {@link ContainerStatus}
 * @public
 */
export declare interface HostConfigStatus {
    PortBindings: PortBindingsStatus;
    RestartPolicy: RestartPolicyStatus;
    Binds: string[] | null;
}

export declare namespace http {
/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }
}

/**
 * An image for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type ImageId = string | Handle<DockerImageInstance>;

/**
 * Function to check whether an {@link @adpt/core#AdaptElement} is an
 * abstract {@link Container}.
 * @public
 */
export declare function isContainerElement(el: AdaptElement): el is AdaptElement<ContainerProps>;

/**
 * Type assertion that tests an element to see if it is a {@link NetworkService}
 *
 * @param el - the element to be tested
 * @returns `true` if  `el` is a NetworkService, `false` otherwise
 *
 * @remarks
 * Also functions as a type assertion for Typescript, so the arguments
 * type will be adjusted to reflect that it is an `AdaptElement<NetworkServiceProps>`
 * instead of a generic `AdaptElement`.
 *
 * @public
 */
export declare function isNetworkServiceElement(el: AdaptElement): el is AdaptElement<NetworkServiceProps>;

export declare namespace k8s {
/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.AdaptElementOrNull;/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      name: string;
      image: string;
      args?: string[];
      command?: string[];
      env?: EnvVar[];
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      tty?: boolean;
      ports?: ContainerPort[];
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: Adapt.GoalStatus, helpers: Adapt.DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @public */
  export declare interface PodProps {
      config: ClusterInfo;
      terminationGracePeriodSeconds?: number;
      children: AdaptElement | AdaptElement[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps> {
      static defaultProps: {
          terminationGracePeriodSeconds: number;
      };
      build(): Adapt.AdaptElementOrNull;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<{} | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} spec
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      selector?: Handle | object;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      apiName: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Pod ... >
   *     <k8s.K8sContainer ... />
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment extends DeferredComponent<ServiceDeploymentProps> {
      build(helpers: BuildHelpers): Adapt.AdaptElement<Adapt.AnyProps>;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourcePod | ResourceService | ResourceCR);/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      apiName: string;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      config: ClusterInfo;
      kind: Kind;
      metadata?: Metadata;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase, WithChildren {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryUrl for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryUrl?: string | DockerSplitRegistryInfo;
  }
}

/**
 * Network links to create for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface Links {
    [internalName: string]: string;
}

/**
 * Element representing a local compute instance
 *
 * @alpha
 */
export declare class LocalCompute extends PrimitiveComponent<ComputeProps> {
    static defaultProps: {
        ip: string;
    };
    static noPlugin: boolean;
}

/** @alpha */
export declare type LocalComputeProps = ComputeProps;

/**
 * @deprecated Use {@link docker.DockerContainer} instead
 * @internal
 */
export declare class LocalContainer extends PrimitiveComponent<ContainerProps> {
}

/**
 * @deprecated Use {@link docker.DockerContainer} instead
 * @internal
 */
export declare type LocalContainerProps = ContainerProps;

/**
 * Represents the local docker host
 *
 * @alpha
 */
export declare class LocalDockerHost extends PrimitiveComponent<DockerHostProps> {
    updateState(state: any): void;
}

/**
 * Find the value of an environment variable in an {@link Environment}
 *
 * @param e - {@link Environment} to search
 * @param name - variable to search for
 * @returns the value of the variable name in e, or undefined if not found
 *
 * @public
 */
export declare function lookupEnvVar(e: Environment, name: string): string | undefined;

/**
 * Creates a function for generating unique names for Adapt Elements.
 * @remarks
 * The unique names are unique by probability, based on a SHA256 hash.
 * They are are made up of:
 *
 * - The Element's key, with any invalid characters removed.
 *
 * - A separator character (or string)
 *
 * - A portion of the SHA256 hash of the Element's ID and the deployID.
 *
 * @param invalidChars - A regular expression that matches all invalid
 * characters that should NOT be included in the resulting name. Must have
 * the global flag set. For example, if only alphabetic characters and dashes
 * are allowed, set `invalidChars` to: `/[^a-zA-Z-]/g`
 * @param maxLen - The maximum allowed length of name that should be generated.
 * @param sep - The separator string to be used between they key and the hash.
 *
 * @public
 */
export declare function makeResourceName(invalidChars: RegExp, maxLen: number, sep?: string): (elemKey: string, elemID: string, deployID: string) => string;

/**
 * Combine multiple {@link Environment} objects into a single array of
 * {@link EnvPair} objects. Returns `undefined` if there are no `Environment`
 * objects provided.
 * @remarks
 * If more than one `Environment` object specifies the same environment variable
 * name, the last one present in the array of arguments takes precedence.
 * @public
 */
export declare function mergeEnvPairs(...envs: (Environment | undefined)[]): EnvPairs | undefined;

/**
 * Combine multiple {@link Environment} objects into a single
 * {@link EnvSimple} object. Returns `undefined` if there are no `Environment`
 * objects provided.
 * @remarks
 * If more than one `Environment` object specifies the same environment variable
 * name, the last one present in the array of arguments takes precedence.
 * @public
 */
export declare function mergeEnvSimple(...envs: (Environment | undefined)[]): EnvSimple | undefined;

export declare namespace mongodb {
/**
   * Abstract MongoDB component
   *
   * @remarks
   * This component is used to denote a needed {@link https://www.mongodb.com | MongoDB}
   * service.  Users should use a style sheet to subsitute a concrete MongoDB instance
   * that provides the service.  {@link mongodb.TestMongoDB} is such a component, suitable for
   * test environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `MONGODB_URI` variable of the form `mongodb://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class MongoDB extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Test {@link https://www.mongodb.com | MongoDB} Service
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * See {@link mongodb.TestMongoDBProps}.
   *
   * @public
   */
  export declare function TestMongoDB(props: SFCDeclProps<TestMongoDBProps, typeof testMongoDefaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link mongodb.TestMongoDB}
   *
   * @public
   */
  export declare interface TestMongoDBProps {
      /** Image used for TestMongoDB container, defaults to mongo:latest */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Mongo DB service is exposed */
      port: number;
  }/**
   * Abstract MongoDB component
   *
   * @remarks
   * This component is used to denote a needed {@link https://www.mongodb.com | MongoDB}
   * service.  Users should use a style sheet to subsitute a concrete MongoDB instance
   * that provides the service.  {@link mongodb.TestMongoDB} is such a component, suitable for
   * test environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `MONGODB_URI` variable of the form `mongodb://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class MongoDB extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Test {@link https://www.mongodb.com | MongoDB} Service
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * See {@link mongodb.TestMongoDBProps}.
   *
   * @public
   */
  export declare function TestMongoDB(props: SFCDeclProps<TestMongoDBProps, typeof testMongoDefaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link mongodb.TestMongoDB}
   *
   * @public
   */
  export declare interface TestMongoDBProps {
      /** Image used for TestMongoDB container, defaults to mongo:latest */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Mongo DB service is exposed */
      port: number;
  }
}

/**
 * Mount information for {@link ContainerStatus}
 * @public
 */
export declare interface MountStatus {
    Type: "bind" | "volume" | "tmpfs";
    Source?: string;
    Destination: string;
    Mode: string;
    RW: boolean;
    Propagation: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
}

/**
 * Type for various network address scopes
 *
 * @remarks
 * The details of this type are very experimental.  Use the constants `NetworkScope.external`
 * and `NetworkScope.default` instead of strings to reduce the chance of breakage.
 *
 * @beta
 */
export declare enum NetworkScope {
    external = "external",
    default = "default"
}

/**
 * An abstract component that represents a network service.
 *
 * @public
 */
export declare abstract class NetworkService extends PrimitiveComponent<NetworkServiceProps> implements NetworkServiceInstance {
    static defaultProps: {
        protocol: string;
        scope: string;
    };
    /**
     * Returns the hostname of the NetworkService, once it is known.
     */
    hostname(scope: NetworkScope): string | undefined;
    /**
     * Returns the port number of the NetworkService, once it is known.
     */
    port(): number | undefined;
}

/**
 * Interface for components that expose Network Services via hostname and port
 *
 * @beta
 */
export declare interface NetworkServiceInstance {
    /**
     * Returns the hostname for the service from the given scope
     *
     * @param scope - the scope of the desired hostname ("default" cluster/internal, "external" - world accessible)
     * @returns - the requested hostname, or undefined if it is not yet available
     *
     * @remarks
     * This function should return the external, world accessible name if there is no cluster/internal only name.
     * The function should throw an error if an external name is requested, but no name/address is available
     * (e.g., the service is internally acessible only.)
     */
    hostname(scope?: NetworkScope): string | undefined;
    /**
     * Returns the TCP or UDP port of the exposed service
     *
     * @remarks
     * Will return undefined if the port information is not yet available
     */
    port(): number | undefined;
}

/**
 * Props for the {@link NetworkService} element
 * @public
 */
export declare interface NetworkServiceProps extends WithChildren {
    /** IP address of the network service */
    ip?: string;
    /** Name of the network service */
    name?: string;
    /** Port on which clients connect to this service */
    port: ServicePort;
    /** Protocol used by the network service */
    protocol?: string;
    /** Scope of the service */
    scope?: NetworkServiceScope;
    /** Port on the endpoint that provides this service */
    targetPort?: ServicePort;
    /** Endpoint that provides the service */
    endpoint?: Handle;
}

/**
 * Network service scope used by {@link NetworkService}
 * @public
 */
export declare type NetworkServiceScope = "local" | "cluster-internal" | "cluster-public" | "external";

export declare namespace nginx {
/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nginx.UrlRouter}
   *
   * @public
   */
  export declare interface UrlRouterProps extends AbsUrlRouterProps {
      debug: boolean;
  }/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nginx.UrlRouter}
   *
   * @public
   */
  export declare interface UrlRouterProps extends AbsUrlRouterProps {
      debug: boolean;
  }/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;
}

export declare namespace nodejs {
/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nodejs.NodeService}.
   * @public
   */
  export declare interface NodeServiceProps {
      /**
       * Image build options to pass to {@link nodejs.LocalNodeImage}.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Handles for services that this component connects to.
       * @remarks
       * The referenced service components must implement the
       * {@link ConnectToInstance} interface. The Node Container will be
       * started with the combined set of environment variables that are
       * provided by all of the referenced components'
       * {@link ConnectToInstance.connectEnv | connectEnv} methods.
       *
       * In case of environment variable naming conflicts among those in
       * from the `connectTo` prop, the value from the handle with the highest
       * index in the `connectTo` array will take precedence.
       * In case of naming conflicts between `connectTo` and `env`, the value
       * in `env` will take precedence.
       * @defaultValue `[]`
       */
      connectTo: Handle<ConnectToInstance> | Handle<ConnectToInstance>[];
      /**
       * Dependencies that must be deployed before the Container image will
       * build.
       * @remarks
       * Note that the NetworkService will also not deploy before the
       * Container image has been built.
       * @defaultValue `[]`
       */
      deps: Handle | Handle[];
      /**
       * Object containing environment variables that the Container will be
       * started with.
       * @defaultValue `{}`
       */
      env: Environment;
      /**
       * The port that the NetworkService will expose.
       * @defaultValue Use the same port number as `port`
       */
      externalPort?: number;
      /**
       * The port number that the Node Container will use.
       * @defaultValue 8080
       */
      port: number;
      /**
       * Scope within which the NetworkService will be exposed.
       * @defaultValue "cluster-internal"
       */
      scope: NetworkServiceScope;
      /**
       * Root directory (which contains package.json) for the Node.js app
       * source code.
       */
      srcDir: string;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link nodejs.LocalNodeImageProps}.
   *
   * @public
   */
  export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link nodejs.LocalNodeImage}
   *
   * @public
   */
  export declare interface LocalNodeImageProps extends Partial<BuiltinProps> {
      /** Source directory for the Node.js program */
      srcDir: string;
      /** Build options */
      options?: NodeImageBuildOptions;
  }/**
   * Options controlling how the Docker image is built in
   * {@link nodejs.LocalNodeImage}.
   * @public
   */
  export declare interface NodeImageBuildOptions extends DockerBuildOptions {
      /**
       * Package manager to use in build steps in the generated Dockerfile
       * that builds {@link nodejs.LocalNodeImage}.
       */
      packageManager?: "npm" | "yarn" | string;
      /**
       * Scripts that are defined in your
       * {@link https://docs.npmjs.com/files/package.json | package.json file}
       * that should be run during the image build.
       */
      runNpmScripts?: string | string[];
      /**
       * Environment variables that should be present during docker build
       *
       * @remarks
       * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
       * variable in the environment before running `docker build`.
       */
      buildArgs?: Environment;
  }/**
   * A partially abstract component that builds
   * {@link https://reactjs.org | ReactJS} source code and serves the resulting
   * files via an {@link http.HttpServer}.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a ReactJS project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `yarn run build`
   *
   * It will then copy the resulting `build` directory into an {@link http.HttpServer}
   * component.
   *
   * Abstract components:
   *
   * This component uses the following abstract components (via
   * {@link http.HttpServer})which must be replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - hostname(): string | undefined
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - port(): number | undefined
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * @public
   */
  export declare function ReactApp(props: SFCDeclProps<ReactAppProps, typeof defaultOptions>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nodejs.ReactApp}.
   * @public
   */
  export declare interface ReactAppProps {
      /**
       * The source code directory to build.
       * @remarks
       * This directory should contain the `package.json` file for the React
       * app.
       */
      srcDir: string;
      /**
       * Options to be passed to the `LocalNodeImage` prop called `options`.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Options to be passed to the `HttpServer` component.
       */
      httpOptions: Partial<HttpServerProps>;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nodejs.NodeService}.
   * @public
   */
  export declare interface NodeServiceProps {
      /**
       * Image build options to pass to {@link nodejs.LocalNodeImage}.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Handles for services that this component connects to.
       * @remarks
       * The referenced service components must implement the
       * {@link ConnectToInstance} interface. The Node Container will be
       * started with the combined set of environment variables that are
       * provided by all of the referenced components'
       * {@link ConnectToInstance.connectEnv | connectEnv} methods.
       *
       * In case of environment variable naming conflicts among those in
       * from the `connectTo` prop, the value from the handle with the highest
       * index in the `connectTo` array will take precedence.
       * In case of naming conflicts between `connectTo` and `env`, the value
       * in `env` will take precedence.
       * @defaultValue `[]`
       */
      connectTo: Handle<ConnectToInstance> | Handle<ConnectToInstance>[];
      /**
       * Dependencies that must be deployed before the Container image will
       * build.
       * @remarks
       * Note that the NetworkService will also not deploy before the
       * Container image has been built.
       * @defaultValue `[]`
       */
      deps: Handle | Handle[];
      /**
       * Object containing environment variables that the Container will be
       * started with.
       * @defaultValue `{}`
       */
      env: Environment;
      /**
       * The port that the NetworkService will expose.
       * @defaultValue Use the same port number as `port`
       */
      externalPort?: number;
      /**
       * The port number that the Node Container will use.
       * @defaultValue 8080
       */
      port: number;
      /**
       * Scope within which the NetworkService will be exposed.
       * @defaultValue "cluster-internal"
       */
      scope: NetworkServiceScope;
      /**
       * Root directory (which contains package.json) for the Node.js app
       * source code.
       */
      srcDir: string;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link nodejs.LocalNodeImageProps}.
   *
   * @public
   */
  export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link nodejs.LocalNodeImage}
   *
   * @public
   */
  export declare interface LocalNodeImageProps extends Partial<BuiltinProps> {
      /** Source directory for the Node.js program */
      srcDir: string;
      /** Build options */
      options?: NodeImageBuildOptions;
  }/**
   * Options controlling how the Docker image is built in
   * {@link nodejs.LocalNodeImage}.
   * @public
   */
  export declare interface NodeImageBuildOptions extends DockerBuildOptions {
      /**
       * Package manager to use in build steps in the generated Dockerfile
       * that builds {@link nodejs.LocalNodeImage}.
       */
      packageManager?: "npm" | "yarn" | string;
      /**
       * Scripts that are defined in your
       * {@link https://docs.npmjs.com/files/package.json | package.json file}
       * that should be run during the image build.
       */
      runNpmScripts?: string | string[];
      /**
       * Environment variables that should be present during docker build
       *
       * @remarks
       * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
       * variable in the environment before running `docker build`.
       */
      buildArgs?: Environment;
  }/**
   * A partially abstract component that builds
   * {@link https://reactjs.org | ReactJS} source code and serves the resulting
   * files via an {@link http.HttpServer}.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a ReactJS project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `yarn run build`
   *
   * It will then copy the resulting `build` directory into an {@link http.HttpServer}
   * component.
   *
   * Abstract components:
   *
   * This component uses the following abstract components (via
   * {@link http.HttpServer})which must be replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - hostname(): string | undefined
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - port(): number | undefined
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * @public
   */
  export declare function ReactApp(props: SFCDeclProps<ReactAppProps, typeof defaultOptions>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nodejs.ReactApp}.
   * @public
   */
  export declare interface ReactAppProps {
      /**
       * The source code directory to build.
       * @remarks
       * This directory should contain the `package.json` file for the React
       * app.
       */
      srcDir: string;
      /**
       * Options to be passed to the `LocalNodeImage` prop called `options`.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Options to be passed to the `HttpServer` component.
       */
      httpOptions: Partial<HttpServerProps>;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nodejs.NodeService}.
   * @public
   */
  export declare interface NodeServiceProps {
      /**
       * Image build options to pass to {@link nodejs.LocalNodeImage}.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Handles for services that this component connects to.
       * @remarks
       * The referenced service components must implement the
       * {@link ConnectToInstance} interface. The Node Container will be
       * started with the combined set of environment variables that are
       * provided by all of the referenced components'
       * {@link ConnectToInstance.connectEnv | connectEnv} methods.
       *
       * In case of environment variable naming conflicts among those in
       * from the `connectTo` prop, the value from the handle with the highest
       * index in the `connectTo` array will take precedence.
       * In case of naming conflicts between `connectTo` and `env`, the value
       * in `env` will take precedence.
       * @defaultValue `[]`
       */
      connectTo: Handle<ConnectToInstance> | Handle<ConnectToInstance>[];
      /**
       * Dependencies that must be deployed before the Container image will
       * build.
       * @remarks
       * Note that the NetworkService will also not deploy before the
       * Container image has been built.
       * @defaultValue `[]`
       */
      deps: Handle | Handle[];
      /**
       * Object containing environment variables that the Container will be
       * started with.
       * @defaultValue `{}`
       */
      env: Environment;
      /**
       * The port that the NetworkService will expose.
       * @defaultValue Use the same port number as `port`
       */
      externalPort?: number;
      /**
       * The port number that the Node Container will use.
       * @defaultValue 8080
       */
      port: number;
      /**
       * Scope within which the NetworkService will be exposed.
       * @defaultValue "cluster-internal"
       */
      scope: NetworkServiceScope;
      /**
       * Root directory (which contains package.json) for the Node.js app
       * source code.
       */
      srcDir: string;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link nodejs.LocalNodeImageProps}.
   *
   * @public
   */
  export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link nodejs.LocalNodeImage}
   *
   * @public
   */
  export declare interface LocalNodeImageProps extends Partial<BuiltinProps> {
      /** Source directory for the Node.js program */
      srcDir: string;
      /** Build options */
      options?: NodeImageBuildOptions;
  }/**
   * Options controlling how the Docker image is built in
   * {@link nodejs.LocalNodeImage}.
   * @public
   */
  export declare interface NodeImageBuildOptions extends DockerBuildOptions {
      /**
       * Package manager to use in build steps in the generated Dockerfile
       * that builds {@link nodejs.LocalNodeImage}.
       */
      packageManager?: "npm" | "yarn" | string;
      /**
       * Scripts that are defined in your
       * {@link https://docs.npmjs.com/files/package.json | package.json file}
       * that should be run during the image build.
       */
      runNpmScripts?: string | string[];
      /**
       * Environment variables that should be present during docker build
       *
       * @remarks
       * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
       * variable in the environment before running `docker build`.
       */
      buildArgs?: Environment;
  }/**
   * A partially abstract component that builds
   * {@link https://reactjs.org | ReactJS} source code and serves the resulting
   * files via an {@link http.HttpServer}.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a ReactJS project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `yarn run build`
   *
   * It will then copy the resulting `build` directory into an {@link http.HttpServer}
   * component.
   *
   * Abstract components:
   *
   * This component uses the following abstract components (via
   * {@link http.HttpServer})which must be replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - hostname(): string | undefined
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - port(): number | undefined
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * @public
   */
  export declare function ReactApp(props: SFCDeclProps<ReactAppProps, typeof defaultOptions>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link nodejs.ReactApp}.
   * @public
   */
  export declare interface ReactAppProps {
      /**
       * The source code directory to build.
       * @remarks
       * This directory should contain the `package.json` file for the React
       * app.
       */
      srcDir: string;
      /**
       * Options to be passed to the `LocalNodeImage` prop called `options`.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Options to be passed to the `HttpServer` component.
       */
      httpOptions: Partial<HttpServerProps>;
  }
}

/**
 * A set of ports to be bound for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface PortBinding {
    [ctrPort: number]: number;
    [ctrPort: string]: number;
}

/**
 * PortBindings for {@link ContainerStatus}
 * @public
 */
export declare interface PortBindingsStatus {
    [ctrPort: string]: PortBindingStatus[];
}

/**
 * PortBinding information for {@link ContainerStatus}
 * @public
 */
export declare interface PortBindingStatus {
    HostIp: string;
    HostPort: string;
}

/**
 * Description of a network port for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type PortDescription = string | number;

export declare namespace postgres {
/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.AdaptElementOrNull;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;
}

export declare namespace redis {
/**
   * Abstract Redis component
   *
   * @remarks
   * This component is used to denote a needed {@link https://redis.io | Redis} service.
   * Users should use a style sheet to subsitute a concrete Redis instance that provides
   * the service.  {@link redis.TestRedis} is such a component, suitable for test
   * environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `REDIS_URI` variable of the form `redis://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class Redis extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Deploys a {@link https://redis.io | Redis} container suitable for testing
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * * See {@link redis.TestRedisProps}.
   *
   * @public
   */
  export declare function TestRedis(props: SFCDeclProps<TestRedisProps, typeof testRedisDefaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link redis.TestRedis}.
   *
   * @public
   */
  export declare interface TestRedisProps {
      /** Image to use for container, defaults to redis:buster */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Redis service is exposed */
      port: number;
  }/**
   * Abstract Redis component
   *
   * @remarks
   * This component is used to denote a needed {@link https://redis.io | Redis} service.
   * Users should use a style sheet to subsitute a concrete Redis instance that provides
   * the service.  {@link redis.TestRedis} is such a component, suitable for test
   * environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `REDIS_URI` variable of the form `redis://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class Redis extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Deploys a {@link https://redis.io | Redis} container suitable for testing
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * * See {@link redis.TestRedisProps}.
   *
   * @public
   */
  export declare function TestRedis(props: SFCDeclProps<TestRedisProps, typeof testRedisDefaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;/**
   * Props for {@link redis.TestRedis}.
   *
   * @public
   */
  export declare interface TestRedisProps {
      /** Image to use for container, defaults to redis:buster */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Redis service is exposed */
      port: number;
  }
}

/**
 * Renames all variables in `e` based on `mapping`
 *
 * @param e - {@link Environment} to rename
 * @param mapping - Object with `(key, value)` pairs that are `(originalName, newName)` pairs.
 *
 * @returns A new {@link Environment} object with all variables renamed according to `mapping`
 *
 * @public
 */
export declare function renameEnvVars(e: Environment, mapping: {
    [orig: string]: string;
}): Environment;

/**
 * The behavior to apply when the container exits.
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface RestartPolicy {
    /** The type of behavior to apply */
    name: RestartPolicyName;
    /** If `OnFailure` is used, the number of times to retry before giving up */
    maximumRetryCount?: number;
}

/**
 * Names for {@link RestartPolicy}
 *
 * @remarks
 * - `Always` - Always restart the container.
 * - `Never` - Do not automatically restart the container.
 * - `OnFailure` - Restart only when the container exit code is non-zero.
 * - `UnlessStopped` - Always restart the container, except if it has been
 *   manually stopped by user intervention.
 *
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type RestartPolicyName = "Always" | "Never" | "OnFailure" | "UnlessStopped";

/**
 * Restart policy status for {@link ContainerStatus}
 * @public
 */
export declare interface RestartPolicyStatus {
    Name: "no" | "always" | "on-failure" | "unless-stopped";
    MaximumRetryCount: number;
}

/**
 * An abstract component that represents a group of components that
 * implements a service. Note that this is not necessarily a network
 * service, but will often be.
 *
 * @remarks
 * Typical children will be {@link NetworkService} and {@link Container} elements.
 *
 * @public
 */
export declare abstract class Service extends Component<ServiceProps, {}> {
}

/**
 * Port for {@link NetworkService }
 * @public
 */
export declare type ServicePort = number | string;

/**
 * Props for {@link Service}
 * @public
 */
export declare interface ServiceProps extends WithChildren {
    /** Optional name for the service */
    name?: string;
}

/**
 * Computes the target port that will be used for a NetworkService
 *
 * @param elemOrProps - a {@link NetworkService} element or its props
 * @returns The target port of the {@link NetworkService} object
 *
 * @public
 */
export declare function targetPort(elemOrProps: NetworkServiceProps | AdaptElement): ServicePort;

/**
 * Updates the names and/or values of variables in an {@link Environment}
 *
 * @param e - The source {@link Environment}
 * @param upd - Updated function that returns an EnvPair with the new name and value of the variable
 * @returns - A new {@link Environment} that is identical to `e` except for the updates done by `upd`
 *
 * @public
 */
export declare function updateEnvVars(e: Environment, upd: (name: string, value: string) => EnvPair | undefined): Environment;

/**
 * Hook that will build an {@link Environment} object from components that comply with {@link ConnectToInstance}
 *
 * @param connectTo - A handle or array of handles that point to components that implement {@link ConnectToInstance}
 * @param xform - A method that can transform the provided environment before it is returned
 * @returns Merged {@link Environment} with variables provided by `connectTo` components, or undefined
 *
 * @remarks
 * Note that this is a hook, and so on first run this will return undefined.
 * After a full build, a state update will trigger a rebuild, at which point
 * the returned Environment will begin to be populated with the variables as
 * the various components are ready to provide them.  However, it can take multiple
 * turns of the build-deploy loop to get all the variables.
 *
 * Moreover, just because a component returns connection information in a variable
 * does not mean it is ready to accept traffic at that time.  Components that use this
 * hook to get connection information for other services must be prepared for those
 * services to be temporarily unavailable.
 *
 * See {@link renameEnvVars} as a function that is useful as an `xform` argument.
 *
 * @public
 */
export declare function useConnectTo(connectTo: Handle | Handle[], xform?: (e: Environment) => Environment): Environment | undefined;

/**
 * Hook that will build an {@link Environment} object from components that comply with {@link ConnectToInstance}
 *
 * @param connectTo - A handle or array of handles that point to components that implement {@link ConnectToInstance}
 * @param options - {@link UseConnectToOptions} options for useConnectTo
 * @returns Merged {@link Environment} with variables provided by `connectTo` components, or undefined
 *
 * @remarks
 * Note that this is a hook, and so on first run this will return undefined.
 * After a full build, a state update will trigger a rebuild, at which point
 * the returned Environment will begin to be populated with the variables as
 * the various components are ready to provide them.  However, it can take multiple
 * turns of the build-deploy loop to get all the variables.
 *
 * Moreover, just because a component returns connection information in a variable
 * does not mean it is ready to accept traffic at that time.  Components that use this
 * hook to get connection information for other services must be prepared for those
 * services to be temporarily unavailable.
 *
 * See {@link renameEnvVars} as a function that is useful as an `xform` option.
 *
 * @public
 */
export declare function useConnectTo(connectTo: Handle | Handle[], options?: UseConnectToOptions): Environment | undefined;

/**
 * Options for {@link useConnectTo}
 *
 * @public
 */
export declare interface UseConnectToOptions {
    /**
     * A function that will transform each environment before it is merged
     *
     * @param e - Environment to be transformed
     * @returns - A transformed Environment
     *
     * @remarks
     * See {@link renameEnvVars} as a function that is useful as an `xform` option.
     */
    xform?: (e: Environment) => Environment;
    /**
     * Scope from which returned connection information should be usable
     */
    scope?: NetworkScope;
}

/**
 * Hook function to translate an {@link ImageId} (which can be either a
 * Handle or an image name string) into an image name string.
 * @beta
 */
export declare function useLatestImageFrom(source: ImageId): string | undefined;

export { }
