import { ChangeType, DependsOnMethod, Handle } from "@adpt/core";
import { Action } from "../action";
import { DockerImageInstance, DockerPushableImageInstance } from "./DockerImage";
import { DockerSplitRegistryInfo, ImageInfo } from "./types";
/**
 * Props for {@link docker.RegistryDockerImage}
 * @public
 */
export interface RegistryDockerImageProps {
    /**
     * Handle for image source
     * @remarks
     * Currently, only handle to LocalDockerImage components and compatible
     * interfaces are supported.
     * @privateRemarks
     * FIXME(manishv) support string refs to other registries and handles of
     * other registry images
     */
    imageSrc: Handle<DockerPushableImageInstance>;
    /**
     * URL or string for the registry where the image should be pushed and pulled
     *
     * @remarks
     * If this parameter is a string, registryUrl will be used for both push and pull
     *
     * If registryUrl is of the form `{ external: string, internal: string }`, docker images wil be
     * pushed to `external` and image strings will refer to `internal`.
     *
     * Note(manishv)
     * This is a bit of a hack to allow one hostname or IP address to push images from outside
     * a particular environment (say k8s) and a different URL for that environment to pull
     * images.
     *
     * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
     * a private registry is running on a docker network attached to the k3s-dind instance, but where we
     * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
     * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
     * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
     * the registry from within Docker, it must use a different address to pull the images for use.
     *
     * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
     * is best if you can arrange to have the same URL or registry string work for all access regardless
     * of which network the registry, Adapt host, and ultimate container running environment is uses.
     */
    registryUrl: string | DockerSplitRegistryInfo;
    /**
     * Tag to use for the image in the registry.
     * @remarks
     * If omitted, the tag from the source is used.  The tag should not
     * include the registry hostname/port prefix.
     */
    newTag?: string;
}
interface State {
    image?: ImageInfo;
    registryUrl?: DockerSplitRegistryInfo;
}
/**
 * Represents a Docker image in a registry.
 * @remarks
 * If the image does not exist in the specified registry, it will be pushed
 * to that registry.
 * @public
 */
export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
    private latestImage_?;
    private latestRegistryUrl_?;
    private registry;
    constructor(props: RegistryDockerImageProps);
    /**
     * Returns information about the version of the Docker image that reflects
     * the current set of props for the component and has been pushed to the
     * registry.
     * @remarks
     * Returns undefined if the `props.imageSrc` component's `latestImage` method
     * returns undefined (depending on the component referenced by
     * `props.imageSrc`, that may indicate the source image has not been built).
     * Also returns undefined if the current image has not yet been
     * pushed to the registry.
     */
    image(): ImageInfo | undefined;
    /**
     * Returns information about the most current version of the Docker image
     * that has been pushed to the registry.
     * @remarks
     * Returns undefined if no image has ever been pushed by this component.
     */
    latestImage(): ImageInfo | undefined;
    /** @internal */
    initialState(): {};
    /** @internal */
    shouldAct(diff: ChangeType): false | {
        act: boolean;
        detail: string;
    };
    /** @internal */
    dependsOn: DependsOnMethod;
    /** @internal */
    action(op: ChangeType): Promise<void>;
    private currentNameTag;
    private srcImageName;
}
export {};
//# sourceMappingURL=RegistryDockerImage.d.ts.map