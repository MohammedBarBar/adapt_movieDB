"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = tslib_1.__importStar(require("@adpt/core"));
const cli_1 = require("./cli");
const DockerContainer_1 = require("./DockerContainer");
const defaultProps = {
    dockerHost: process.env.DOCKER_HOST,
    imageTag: "2",
    port: 5000,
};
/**
 * Runs a Docker registry in a container.
 * @remarks
 * Implements {@link docker.DockerRegistryInstance}.
 *
 * @public
 */
function LocalDockerRegistry(props) {
    const _a = props, { handle: _h, imageTag, port, portBindings: portBindingsIn } = _a, buildProps = tslib_1.__rest(_a, ["handle", "imageTag", "port", "portBindings"]);
    const hardCodedInternalPort = 5000;
    let portBindings = portBindingsIn;
    if (port !== undefined) {
        if (!portBindings)
            portBindings = {};
        portBindings[hardCodedInternalPort] = port;
    }
    const ctr = core_1.handle();
    const dockerHost = buildProps.dockerHost;
    const image = `registry:${imageTag}`;
    const ipAddr = core_1.useMethod(ctr, undefined, "dockerIP", props.networks && props.networks[0]);
    function registry(network) {
        let netIP = ipAddr;
        if (network)
            netIP = core_1.callInstanceMethod(ctr, undefined, "dockerIP", network);
        if (netIP === undefined)
            return undefined;
        return `${netIP}:${hardCodedInternalPort}`;
    }
    core_1.useDeployedWhen(async (goal) => {
        // No need to check for destroy
        if (goal !== core_1.GoalStatus.Deployed)
            return true;
        let reason;
        if (ipAddr) {
            try {
                await cli_1.dockerRun({
                    autoRemove: true,
                    background: false,
                    image: cli_1.busyboxImage,
                    dockerHost,
                    command: ["wget", "--spider", `http://${registry()}/v2/`],
                });
                return true;
            }
            catch (err) {
                reason = err.message;
            }
        }
        else {
            reason = "No IP address for container";
        }
        return core_1.waiting(`Waiting for registry to become ready (${reason})`);
    });
    core_1.useImperativeMethods(() => ({
        registry,
    }));
    return core_1.default.createElement(DockerContainer_1.DockerContainer, Object.assign({ handle: ctr, image: image, portBindings: portBindings }, buildProps));
}
exports.LocalDockerRegistry = LocalDockerRegistry;
// TODO: The "as any" is a workaround for an api-extractor bug. See issue #185.
LocalDockerRegistry.defaultProps = defaultProps;
//# sourceMappingURL=LocalDockerRegistry.js.map