import { ChangeType, DeployOpID, GoalStatus } from "@adpt/core";
import { Action, ActionContext, ShouldAct } from "../action";
import { DockerPushableImageInstance } from "./DockerImage";
import { DockerBuildOptions, File, ImageInfo, NameTagString, Stage } from "./types";
/**
 * Props for {@link docker.LocalDockerImage}
 *
 * @public
 */
export interface LocalDockerImageProps {
    /** Directory for use as the build context in docker build */
    contextDir?: string;
    /**
     * Contents of the dockerfile
     *
     * @remarks
     * Should not be used if dockerfileName is set
     */
    dockerfile?: string;
    /**
     * Path to a local Dockerfile in the Adapt project.
     *
     * @remarks
     * This path is relative to the root of the Adapt project.
     * Should not be used if `dockerfile` is set.
     */
    dockerfileName?: string;
    /**
     * Extra files that should be included during the docker build
     *
     * @remarks
     * LocalDockerImage uses a multi-stage build process.  It first creates
     * a temporary image that includes the files specified in this field.
     * This temporary image is then made available to the `dockerfile` with
     * stage name `files` and can then be copied into the final image, as
     * desired, using `COPY` or `ADD` commands in the `dockerfile`.
     *
     * @example
     * To create a final Docker image that contains a file that has some
     * programmatically created content, use the `dockerfile` prop along
     * with the `files` prop like this:
     * ```tsx
     * const files = [{
     *   path: '/path/to/myfile.txt',
     *   contents: 'contents for myfile\n'
     * }];
     * const dockerfile = `
     *   FROM alpine
     *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
     *   ...
     * `;
     * return <LocalDockerImage files={files} dockerfile={dockerfile} />
     * ```
     */
    files?: File[];
    /**
     * Options to control the behavior of docker build
     */
    options?: DockerBuildOptions;
    /**
     * Extra stages to include in a multi-stage docker build
     */
    stages?: Stage[];
}
/**
 * @internal
 */
export interface LocalDockerImageState {
    deployOpID?: DeployOpID;
    image?: ImageInfo;
    imagePropsJson?: string;
    prevUniqueTag?: string;
}
/**
 * Locally builds a docker image
 *
 * @remarks
 * See {@link docker.LocalDockerImageProps}.
 *
 * @public
 */
export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
    static defaultProps: {
        options: {
            dockerHost: string | undefined;
            forceRm: boolean;
        };
    };
    deployedWhenIsTrivial: boolean;
    private image_?;
    private imagePropsJson_?;
    private options_;
    constructor(props: LocalDockerImageProps);
    buildComplete(): boolean;
    ready(): boolean;
    image(): ImageInfo | undefined;
    pushTo(registryUrl: string, newTag?: NameTagString): Promise<undefined | ImageInfo>;
    latestImage(): ImageInfo | undefined;
    /**
     * User-facing name to display in status messages.
     */
    displayName(): string | undefined;
    /**
     * Implementations for Action base class
     * @internal
     */
    shouldAct(op: ChangeType): Promise<ShouldAct>;
    /**
     * Implementations for Action base class
     * @internal
     */
    action(op: ChangeType, ctx: ActionContext): Promise<void>;
    /** @internal */
    initialState(): {};
    /** @internal */
    deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
    /** @internal */
    protected readonly imagePropsJson: string;
}
//# sourceMappingURL=LocalDockerImage.d.ts.map