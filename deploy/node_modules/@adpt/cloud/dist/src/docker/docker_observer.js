"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@adpt/core");
const fs = tslib_1.__importStar(require("fs-extra"));
const graphql_1 = require("graphql");
const js_yaml_1 = require("js-yaml");
const json_stable_stringify_1 = tslib_1.__importDefault(require("json-stable-stringify"));
const path_1 = tslib_1.__importDefault(require("path"));
const url_1 = tslib_1.__importDefault(require("url"));
const swagger2gql_1 = tslib_1.__importDefault(require("../../src/swagger2gql"));
// tslint:disable-next-line:no-var-requires
const fetchu = require("fetchu");
// tslint:disable-next-line:no-var-requires
const swaggerClient = require("swagger-client");
const infoSym = Symbol("dockerInfoSym");
function computeQueryId(clusterId, fieldName, args) {
    return json_stable_stringify_1.default({
        clusterId,
        fieldName,
        args,
    });
}
const dockerObserveResolverFactory = {
    fieldResolvers: (_type, fieldName, isQuery) => {
        if (!isQuery)
            return;
        if (fieldName === "withDockerHost") {
            return async (_obj, args, _context) => {
                const dockerHost = args.dockerHost;
                if (dockerHost === undefined)
                    throw new Error("No dockerHost specified");
                return { [infoSym]: { dockerHost } };
            };
        }
        return async (obj, args, context, _info) => {
            const req = await swaggerClient.buildRequest({
                spec: dockerSwagger(),
                operationId: fieldName,
                parameters: args,
                requestContentType: "application/json",
                responseContentType: "application/json"
            });
            const dockerHost = obj[infoSym].dockerHost;
            if (dockerHost == null)
                throw new Error(`Internal error: dockerHost is null`);
            const url = url_1.default.parse(dockerHost);
            const queryId = computeQueryId(obj[infoSym].dockerHost, fieldName, args);
            const ret = (url.protocol === "file:" || url.protocol === "unix:") ?
                await fetchu(Object.assign({ socketPath: url.pathname, path: req.url }, req)) :
                await fetchu(dockerHost + req.url, req);
            context[queryId] = ret; //Overwrite in case data got updated on later query
            return ret;
        };
    }
};
const dockerQueryResolverFactory = {
    fieldResolvers: (_type, fieldName, isQuery) => {
        if (!isQuery)
            return;
        if (fieldName === "withDockerHost") {
            return async (_obj, args, _context) => {
                const dockerHost = args.dockerHost;
                if (dockerHost === undefined)
                    throw new Error("No dockerHost specified");
                return { [infoSym]: { dockerHost } };
            };
        }
        return async (obj, args, context, _info) => {
            const queryId = computeQueryId(obj[infoSym].dockerHost, fieldName, args);
            if (!context)
                throw new core_1.ObserverNeedsData();
            if (!Object.hasOwnProperty.call(context, queryId))
                throw new core_1.ObserverNeedsData();
            return context[queryId];
        };
    }
};
function buildSchema(resolverFactory) {
    const schema = swagger2gql_1.default(dockerSwagger(), resolverFactory);
    const queryOrig = schema.getQueryType();
    if (queryOrig === undefined)
        throw new Error("Internal error, invalid schema");
    if (queryOrig === null)
        throw new Error("Internal Error, invalid schema");
    const dockerQuery = Object.create(queryOrig);
    dockerQuery.name = "DockerApi";
    const query = new graphql_1.GraphQLObjectType({
        name: "Query",
        fields: () => ({
            withDockerHost: {
                type: dockerQuery,
                args: {
                    dockerHost: {
                        type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
                    }
                },
                resolve: resolverFactory.fieldResolvers ?
                    resolverFactory.fieldResolvers(query, "withDockerHost", true) :
                    () => undefined
            }
        }),
    });
    const dockerObserverSchema = new graphql_1.GraphQLSchema({
        query
    });
    return dockerObserverSchema;
}
let _dockerSwagger;
function dockerSwagger() {
    if (_dockerSwagger)
        return _dockerSwagger;
    const text = fs.readFileSync(path_1.default.join(__dirname, "docker_swagger.yaml"));
    _dockerSwagger = js_yaml_1.safeLoad(text.toString());
    return _dockerSwagger;
}
function buildObserveSchema() {
    return buildSchema(dockerObserveResolverFactory);
}
function buildQuerySchema() {
    return buildSchema(dockerQueryResolverFactory);
}
//Building these can be very slow so we wait for someone to use our observer
let querySchema;
let observeSchema;
class DockerObserver {
    constructor() {
        this.observe = async (queries) => {
            const observations = {};
            if (queries.length > 0) {
                if (!observeSchema)
                    observeSchema = buildObserveSchema();
                const waitFor = queries.map((q) => Promise.resolve(graphql_1.execute(observeSchema, q.query, null, observations, q.variables)));
                core_1.throwObserverErrors(await Promise.all(waitFor));
            }
            return { context: observations };
        };
    }
    get schema() {
        if (!querySchema)
            querySchema = buildQuerySchema();
        return querySchema;
    }
}
exports.DockerObserver = DockerObserver;
core_1.registerObserver(new DockerObserver());
//# sourceMappingURL=docker_observer.js.map