"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@adpt/core");
const utils_1 = require("@adpt/utils");
const CFResource_1 = require("./CFResource");
exports.adaptDeployIdTag = "adapt:deployID";
exports.adaptStackIdTag = "adapt:stackID";
exports.adaptResourceIdTag = "adapt:resourceID";
function addTag(input, tag, value) {
    if (input.Tags == null)
        input.Tags = [];
    for (const t of input.Tags) {
        if (t.Key === tag) {
            t.Value = value;
            return;
        }
    }
    input.Tags.push({
        Key: tag,
        Value: value,
    });
}
exports.addTag = addTag;
function getTag(obj, tag) {
    if (obj.Tags) {
        for (const t of obj.Tags) {
            if (t.Key === tag)
                return t.Value;
        }
    }
    return undefined;
}
exports.getTag = getTag;
function adaptResourceId(elemOrHandle) {
    const el = core_1.isHandle(elemOrHandle) ? elemOrHandle.target : elemOrHandle;
    if (el == null) {
        throw new Error(`Cannot get a CloudFormation resource ID ` +
            `for an unassociated handle`);
    }
    if (!CFResource_1.isCFResourcePrimitiveElement(el)) {
        throw new Error(`Cannot get a CloudFormation resource ID for an ` +
            `element that is not a CFResourcePrimitive`);
    }
    return adaptIdFromElem(el.props.Type, el);
}
exports.adaptResourceId = adaptResourceId;
function adaptIdFromElem(prefix, el) {
    if (!core_1.isMountedElement(el)) {
        throw new Error("Can only compute name of mounted elements");
    }
    return adaptId(prefix, el.id);
}
exports.adaptIdFromElem = adaptIdFromElem;
function adaptId(prefix, elementId) {
    const replaceRe = /[^a-z0-9]/ig;
    const name = prefix + utils_1.sha256hex(elementId).slice(0, 32);
    // Remove all invalid chars
    return name.replace(replaceRe, "");
}
exports.adaptId = adaptId;
//# sourceMappingURL=plugin_utils.js.map