"use strict";
/*
 * Copyright 2018-2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@adpt/core");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const graphql_1 = require("graphql");
const js_yaml_1 = require("js-yaml");
const path_1 = tslib_1.__importDefault(require("path"));
const swagger2gql_1 = tslib_1.__importDefault(require("../../src/swagger2gql"));
const aws_sdk_1 = tslib_1.__importDefault(require("./aws-sdk"));
const observer_common_1 = require("./observer_common");
const observeResolverFactory = {
    fieldResolvers: (_type, fieldName, isQuery) => {
        if (!isQuery)
            return;
        if (fieldName === observer_common_1.withParamsProp) {
            return async (_obj, args, _context) => {
                return { [observer_common_1.infoSym]: args };
            };
        }
        return async (obj, args, context, _info) => {
            const params = obj[observer_common_1.infoSym];
            const queryId = observer_common_1.computeQueryId(obj[observer_common_1.infoSym], fieldName, args);
            const client = new aws_sdk_1.default.EC2({
                region: params.awsRegion,
                accessKeyId: params.awsAccessKeyId,
                secretAccessKey: params.awsSecretAccessKey,
            });
            // Make the query to AWS
            const ret = await client[observer_common_1.opName(fieldName)](args.body).promise();
            context[queryId] = ret; //Overwrite in case data got updated on later query
            return ret;
        };
    }
};
const queryResolverFactory = {
    fieldResolvers: (_type, fieldName, isQuery) => {
        if (!isQuery)
            return;
        if (fieldName === observer_common_1.withParamsProp) {
            return async (_obj, args, _context) => {
                return { [observer_common_1.infoSym]: args };
            };
        }
        return async (obj, args, context, _info) => {
            const queryId = observer_common_1.computeQueryId(obj[observer_common_1.infoSym], fieldName, args);
            if (!context)
                throw new core_1.ObserverNeedsData();
            if (!Object.hasOwnProperty.call(context, queryId))
                throw new core_1.ObserverNeedsData();
            return context[queryId];
        };
    }
};
function buildSchema(resolverFactory) {
    const schema = swagger2gql_1.default(swaggerDef(), resolverFactory);
    const queryOrig = schema.getQueryType();
    if (queryOrig == null)
        throw new Error("Internal Error, invalid schema");
    const type = Object.create(queryOrig);
    type.name = "AwsApi";
    const query = new graphql_1.GraphQLObjectType({
        name: "Query",
        fields: () => ({
            [observer_common_1.withParamsProp]: {
                type,
                args: {
                    awsAccessKeyId: {
                        type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
                    },
                    awsSecretAccessKey: {
                        type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
                    },
                    awsRegion: {
                        type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
                    },
                },
                resolve: resolverFactory.fieldResolvers ?
                    resolverFactory.fieldResolvers(query, observer_common_1.withParamsProp, true) :
                    () => undefined
            }
        }),
    });
    const observerSchema = new graphql_1.GraphQLSchema({
        query
    });
    return observerSchema;
}
let _swaggerDef;
function swaggerDef() {
    if (_swaggerDef)
        return _swaggerDef;
    const text = fs_extra_1.default.readFileSync(path_1.default.join(__dirname, "ec2_swagger.yaml"));
    _swaggerDef = js_yaml_1.safeLoad(text.toString());
    return _swaggerDef;
}
function buildObserveSchema() {
    return buildSchema(observeResolverFactory);
}
function buildQuerySchema() {
    return buildSchema(queryResolverFactory);
}
//Building these can be very slow so we wait for someone to use our observer
let querySchema;
let observeSchema;
class AwsEc2Observer {
    constructor() {
        this.observe = async (queries) => {
            const observations = {};
            if (queries.length > 0) {
                if (!observeSchema)
                    observeSchema = buildObserveSchema();
                const waitFor = queries.map((q) => Promise.resolve(graphql_1.execute(observeSchema, q.query, null, observations, q.variables)));
                core_1.throwObserverErrors(await Promise.all(waitFor));
            }
            return { context: observations };
        };
    }
    get schema() {
        if (!querySchema)
            querySchema = buildQuerySchema();
        return querySchema;
    }
}
exports.AwsEc2Observer = AwsEc2Observer;
core_1.registerObserver(new AwsEc2Observer());
//# sourceMappingURL=ec2_observer.js.map