"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@adpt/core");
const utils_1 = require("@adpt/utils");
const execa_1 = tslib_1.__importDefault(require("execa"));
const util_1 = require("util");
const Action_1 = require("./Action");
async function runCommand(cmd, cmdName, log, allowCode1 = false) {
    if (cmd.length === 0)
        throw new Error(`Command ${cmdName} array must have at least 1 entry`);
    const exec = cmd[0];
    if (!exec)
        throw new Error(`Command ${cmdName} invalid: ${util_1.inspect(cmd)}`);
    try {
        const ret = await execa_1.default(exec, cmd.slice(1));
        if (ret.stdout)
            log.info(ret.stdout);
        if (ret.stderr)
            log.error(ret.stderr);
        return 0;
    }
    catch (err) {
        err = utils_1.ensureError(err);
        // execa throws a plain Error, but with additional stuff attached
        if (err.failed === true && err.exitCode !== undefined) {
            if (err.stdout)
                log.info(err.stdout);
            if (err.stderr)
                log.error(err.stderr);
            if (allowCode1 && err.exitCode === 1)
                return 1;
            const output = err.stderr || err.stdout;
            let msg = `Command ${cmdName} (${cmd.join(" ")}) failed. [returned ${err.exitCode}]`;
            if (output)
                msg += `:\n${output}`;
            throw new Error(msg);
        }
        throw err;
    }
}
/**
 * Primitive component that can be used to interact with commands via the
 * OS shell to implement actions in Adapt.
 * @public
 */
class Command extends Action_1.Action {
    async shouldAct(op, ctx) {
        let detail = "Running command: ";
        if (op === core_1.ChangeType.delete) {
            if (!this.props.delete)
                return { act: false, detail: "No delete command" };
            detail += this.props.delete.join(" ");
            if (!this.props.shouldDelete)
                return { act: true, detail };
        }
        else {
            detail += this.props.run.join(" ");
            if (!this.props.shouldRun)
                return { act: true, detail };
        }
        const cmdName = op === core_1.ChangeType.delete ? "shouldDelete" : "shouldRun";
        const cmd = this.props[cmdName];
        if (!cmd)
            throw new Error(`Earlier cmd check failed`);
        const cmdRet = await runCommand(cmd, cmdName, ctx.logger, true);
        return {
            act: cmdRet === 0,
            detail,
        };
    }
    async action(op, ctx) {
        const cmdName = op === core_1.ChangeType.delete ? "delete" : "run";
        const cmd = this.props[cmdName];
        if (!cmd) {
            const msg = op === core_1.ChangeType.delete ?
                `Command delete action run without delete action defined` :
                `Command run array is null`;
            throw new Error(msg);
        }
        await runCommand(cmd, cmdName, ctx.logger);
    }
}
exports.Command = Command;
//# sourceMappingURL=Command.js.map