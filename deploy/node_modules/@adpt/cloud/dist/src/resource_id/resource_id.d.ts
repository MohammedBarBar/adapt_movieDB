import { TupleToUnion } from "@adpt/utils";
import { RequiredDeepT } from "type-ops";
export declare enum ResourceIdPolicy {
    local = "local",
    default = "local",
    globalCreateOnly = "globalCreateOnly",
    globalUseOnly = "globalUseOnly",
    globalCreateOrUse = "globalCreateOrUse"
}
export interface ResourceIdOptions {
    defaultBaseId?: ResourceIdBase;
    maxIdLength?: number | null;
    randLength?: number;
    separator?: string;
}
export declare type ResourceIdBase = string | null;
export interface ResourceId {
    baseId: ResourceIdBase;
    policy?: ResourceIdPolicy;
    options?: ResourceIdOptions;
}
export declare type ResourceIdConfig = RequiredDeepT<ResourceId>;
export declare type ResourceIdList = string[];
/**
 * Creates a tuple of the names of a set of properties. This can then be used
 * subsequently for both static type operations and runtime manipulation.
 *
 * @param idPropNames The string literal names of object properties that
 * should be ResourceIds.
 */
export declare function resourceIdList<T extends ResourceIdList>(...idPropNames: T): T;
/**
 * Given a tuple type (generated using typeof on the object returned by
 * resourceIdList), returns an object type that can be added to a
 * component's Props where all the properties for
 * keys specified in the resourceIdList have the correct type.
 * Currently that type is (ResourceId | string | null).
 */
export declare type ResourceIdProps<IdListType extends ResourceIdList> = Record<TupleToUnion<IdListType>, ResourceId | ResourceIdBase>;
/**
 * Given a ResourceIdList type, returns an object type where all of the
 * property names specified in resourceIdList have type string.
 */
export declare type ResourceIdStringProps<IdListType extends ResourceIdList> = Record<TupleToUnion<IdListType>, string>;
/**
 * Given a tuple type (see above), returns an object type that can be
 * added to a component's state object to keep track of any dynamically
 * generated ResourceId names.
 */
export interface ResourceIdState<IdListType extends ResourceIdList> {
    adaptResourceIds?: Record<TupleToUnion<IdListType>, StateEntry>;
}
export declare function idToString(config: ResourceIdConfig): string;
export declare function resourceIdConfig(id: ResourceId | string | null, policy: ResourceIdPolicy, options: ResourceIdOptions): ResourceIdConfig;
export declare function resourceIdConfig(id: unknown, policy: ResourceIdPolicy, options: ResourceIdOptions): undefined;
export interface StateWithResourceIds<Keys extends string = string> {
    adaptResourceIds: StateEntries<Keys>;
}
export interface StateEntry {
    configured: ResourceIdConfig;
    currentId: string;
}
declare type StateEntries<Keys extends string = string> = Record<Keys, StateEntry>;
declare type GetResourceIdKeys<State extends object> = State extends Partial<StateWithResourceIds<infer Ids>> ? Ids : never;
export declare function updateResourceIdState<State extends Partial<StateWithResourceIds>, IdList extends GetResourceIdKeys<State>[], Props extends ResourceIdProps<IdList>>(idList: IdList, props: Props, state: State, policy?: ResourceIdPolicy, options?: ResourceIdOptions): StateWithResourceIds<GetResourceIdKeys<State>>;
export declare function getResourceIds<State extends Partial<StateWithResourceIds>, IdList extends GetResourceIdKeys<State>[]>(idList: IdList, state: State): Record<GetResourceIdKeys<State>, string> | undefined;
export {};
//# sourceMappingURL=resource_id.d.ts.map