"use strict";
/*
 * Copyright 2019 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const yaml = tslib_1.__importStar(require("js-yaml"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const util = tslib_1.__importStar(require("util"));
const env_1 = require("../env");
const kubectl_1 = require("./kubectl");
async function getKubeconfigFromPath(path) {
    const kenv = path ? { KUBECONFIG: path } : {};
    const result = await kubectl_1.kubectl(["config", "view", "-o", "json", "--flatten"], { env: env_1.mergeEnvSimple(process.env, kenv) });
    const json = result.stdout;
    return JSON.parse(json);
}
async function getKubeconfig(configStr) {
    const errors = [];
    let kubeconfig;
    //JSON
    try {
        kubeconfig = JSON.parse(configStr);
    }
    catch (e) {
        errors.push({ attempt: "as JSON", message: e.message });
    }
    //FIXME(manishv) better validation of returned data here
    if ((kubeconfig != null) && !lodash_1.default.isObject(kubeconfig)) {
        throw new Error(`Invalid kubeconfig in JSON from ${configStr}`);
    }
    if (lodash_1.default.isArray(kubeconfig))
        throw new Error(`Invalid array kubeconfig in JSON from ${configStr}`);
    if (kubeconfig !== undefined)
        return kubeconfig;
    //YAML
    try {
        kubeconfig = yaml.safeLoad(configStr); //FIXME(manishv) Put a Kubeconfig schema to validate YAML
    }
    catch (e) {
        errors.push({ attempt: "as YAML", message: e.message });
    }
    if ((kubeconfig != null) && !lodash_1.default.isObject(kubeconfig)) {
        if (lodash_1.default.isString(kubeconfig)) {
            kubeconfig = undefined; //Try this as a path, since a path will look like a valid YAML
        }
        else {
            throw new Error(`Invalid kubeconfig in YAML from ${configStr}`);
        }
    }
    if (lodash_1.default.isArray(kubeconfig))
        throw new Error(`Invalid array kubeconfig in YAML from ${configStr}`);
    if (kubeconfig !== undefined)
        return kubeconfig;
    try {
        return getKubeconfigFromPath(configStr);
    }
    catch (e) {
        errors.push({ attempt: "from KUBECONFIG", message: e.message });
    }
    throw new Error(errors.map((e) => `Could not get kubeconfig ${e.attempt}:\n${e.message}\n-------\n`).join("\n"));
}
/**
 * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
 *
 * @remarks
 *
 * This function will take a set of options and generate a {@link k8s.ClusterInfo}
 * object that contains the kubeconfig, registryUrl for private images, and any other
 * relevant information for the cluster
 *
 * See {@link k8s.MakeClusterInfoOptions} for information on how the information
 * is computed.
 *
 * @returns A {@link k8s.ClusterInfo} object.
 *
 * @public
 */
async function makeClusterInfo(options) {
    const registryUrl = options.registryUrl;
    if (options.kubeconfig === undefined) {
        return { kubeconfig: await getKubeconfigFromPath(process.env.KUBECONFIG), registryUrl };
    }
    if (lodash_1.default.isString(options.kubeconfig)) {
        return { kubeconfig: await getKubeconfig(options.kubeconfig), registryUrl };
    }
    if (lodash_1.default.isObject(options.kubeconfig)) {
        return { kubeconfig: options.kubeconfig, registryUrl };
    }
    throw new Error(`Illegal kubeconfig option in ${util.inspect(options)}`);
}
exports.makeClusterInfo = makeClusterInfo;
//# sourceMappingURL=utils.js.map