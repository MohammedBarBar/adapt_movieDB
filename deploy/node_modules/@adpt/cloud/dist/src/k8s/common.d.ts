import { BuildData, ObserveForStatus, WithChildren } from "@adpt/core";
import { DockerSplitRegistryInfo } from "../docker";
import { PodSpec } from "./Pod";
import { ServiceSpec } from "./Service";
/**
 * Kubernetes Kind
 *
 * @public
 */
export declare type Kind = string;
/** @public */
export interface CRSpec {
    [key: string]: any;
}
/** @public */
export declare type Spec = PodSpec | ServiceSpec | CRSpec;
/** @public */
export interface Metadata {
    namespace?: string;
    labels?: {
        [key: string]: string;
    };
    annotations?: {
        [key: string]: string;
    };
}
/** @public */
export declare type ResourceProps = {
    key: string;
} & (ResourcePod | ResourceService | ResourceCR);
/** @public */
export interface ResourceInfo {
    kind: Kind;
    apiName: string;
    statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
    specsEqual(actual: Spec, element: Spec): boolean;
}
/**
 * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
 *
 * @public
 */
export interface ClusterInfo {
    /** Javascript object formed by parsing a valid kubeconfig file */
    kubeconfig: Kubeconfig;
    /**
     * URL or string to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
     *
     * @remarks
     * If `registryUrl` is a string, it is assumed that the cluster can pull from the same string
     * that outsiders can push to.
     *
     * If `registryUrl` is of the form `{ external: string, internal: string }` then the `external`
     * string will be used to push images, and the `internal` string will be used to pull images.
     *
     * Note(manishv)
     * This is a bit of a hack to allow one hostname or IP address to push images from outside
     * a particular environment (say k8s) and a different URL for that environment to pull
     * images.
     *
     * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
     * a private registry is running on a docker network attached to the k3s-dind instance, but where we
     * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
     * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
     * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
     * the registry from within Docker, it must use a different address to pull the images for use.
     *
     * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
     * is best if you can arrange to have the same URL or registry string work for all access regardless
     * of which network the registry, Adapt host, and ultimate container running environment uses.
     */
    registryUrl?: string | DockerSplitRegistryInfo;
}
/** @public */
export interface ResourceBase {
    config: ClusterInfo;
    kind: Kind;
    metadata?: Metadata;
}
/** @public */
export interface ResourcePod extends ResourceBase, WithChildren {
    kind: "Pod";
    spec: PodSpec;
}
/** @public */
export interface ResourceService extends ResourceBase {
    kind: "Service";
    spec: ServiceSpec;
}
/** @public */
export interface ResourceCR extends ResourceBase {
    kind: string;
    spec: CRSpec;
}
/** @public */
export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;
/** @public */
export interface Kubeconfig {
    apiVersion?: "v1";
    kind: "Config";
    "current-context": string;
    contexts: {
        name: string;
        context: {
            cluster: string;
            user: string;
        };
    }[];
    clusters: {
        name: string;
        cluster: {
            "certificate-authority-data": string;
            server: string;
        };
    }[];
    preferences?: unknown;
    users: {
        name: string;
        user: {
            "client-certificate-data"?: string;
            "client-key-data"?: string;
            "username"?: string;
            "password"?: string;
        };
    }[];
}
//# sourceMappingURL=common.d.ts.map