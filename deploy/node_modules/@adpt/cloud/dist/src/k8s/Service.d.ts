import Adapt, { BuiltinProps, Handle, SFCDeclProps } from "@adpt/core";
import { NetworkServiceProps } from "../NetworkService";
import { ClusterInfo, ResourceProps } from "./common";
/** @public */
export interface ServiceProps extends ServiceSpec {
    /** Legal configuration loaded from kubeconfig */
    config: ClusterInfo;
    selector?: Handle | object;
}
/** @public */
export interface ServiceSpec {
    /**
     * Cluster IP for a {@link k8s.Service}
     *
     * @remarks
     * `clusterIP` is the IP address of the service and is usually assigned
     * randomly by the master. If an address is specified manually and is not
     * in use by others, it will be allocated to the service; otherwise,
     * creation of the service will fail. This field can not be changed through
     * updates. Valid values are "None", empty string (""), or a valid IP
     * address. "None" can be specified for headless services when proxying is
     * not required. Only applies to types ClusterIP, NodePort, and
     * LoadBalancer. Ignored if type is ExternalName.
     *
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
     * Kubernetes documentation}.
     */
    clusterIP?: string;
    /**
     * A list of IP addresses for which nodes in the cluster
     * will also accept traffic for this service.
     *
     * @remarks
     * These IPs are not managed by
     * Kubernetes. The user is responsible for ensuring that traffic arrives at
     * a node with this IP. A common example is external load balancers that are
     * not part of the Kubernetes system.
     */
    externalIPs?: string[];
    /**
     * The external reference that kubedns or equivalent
     * will return as a CNAME record for this service.
     *
     * @remarks
     * No proxying will be involved. Must be a
     * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
     * and requires Type to be ExternalName.
     */
    externalName?: string;
    /**
     * Denotes if this Service desires to route
     * external traffic to node-local or cluster-wide endpoints.
     *
     * @remarks
     * "Local" preserves the client source IP and avoids a second hop for
     * LoadBalancer and Nodeport type services, but risks potentially
     * imbalanced traffic spreading. "Cluster" obscures the client source IP
     * and may cause a second hop to another node, but should have good overall
     * load-spreading.
     */
    externalTrafficPolicy?: string;
    /**
     * Specifies the healthcheck nodePort for the service.
     *
     * @remarks
     * If not specified, HealthCheckNodePort is created by the service
     * api backend with the allocated nodePort. Will use user-specified nodePort
     * value if specified by the client. Only affects when Type is set to
     * LoadBalancer and ExternalTrafficPolicy is set to Local.
     */
    healthCheckNodePort?: number;
    /**
     * Only applies to Service Type: LoadBalancer. LoadBalancer will
     * get created with the IP specified in this field.
     *
     * @remarks
     * This feature depends on
     * whether the underlying cloud provider supports specifying the loadBalancerIP
     * when a load balancer is created. This field will be ignored if the
     * cloud provider does not support the feature.
     */
    loadBalancerIP?: string;
    /**
     * If specified and supported by the platform, this will
     * restrict traffic through the cloud provider load balancer
     * to the specified client IPs.
     *
     * @remarks
     * This field will be ignored if the cloud provider
     * does not support the feature.
     *
     * For more information, see the
     * {@link https://v1-16.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
     * Kubernetes documentation}.
     */
    loadBalancerSourceRanges?: string[];
    /**
     * The list of ports that are exposed by this service.
     *
     * @remarks
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
     * Kubernetes documentation}.
     */
    ports?: ServicePort[];
    /**
     * When set to true, indicates that
     * DNS implementations must publish the notReadyAddresses of subsets for the
     * Endpoints associated with the Service.
     *
     * @remarks
     * The default value is false. The
     * primary use case for setting this field is to use a StatefulSet's Headless
     * Service to propagate SRV records for its Pods without respect to their
     * readiness for purpose of peer discovery.
     */
    publishNotReadyAddresses?: boolean;
    /**
     * Route service traffic to pods with label keys and values
     * matching this selector.
     *
     * @remarks
     * If empty or not present, the service is assumed to
     * have an external process managing its endpoints, which Kubernetes will not
     * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
     * Ignored if type is ExternalName.
     *
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
     * Kubernetes documentation}.
     */
    selector?: object;
    /**
     * Used to maintain session affinity.
     *
     * @remarks
     * Possible values are:
     *
     * - `"ClientIP"`: Enables client IP based session affinity.
     *
     * - `"None"`: Disables session affinity.
     *
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
     * Kubernetes documentation}.
     * @defaultValue `"None"`
     */
    sessionAffinity?: string;
    /**
     * Determines how the Service is exposed.
     *
     * @remarks
     * Valid options are:
     *
     * - `"ExternalName"`: maps to the specified externalName.
     *
     * - `"ClusterIP"`: allocates a cluster-internal IP address for load
     * balancing to endpoints. Endpoints are determined by the selector or if
     * that is not specified, by manual construction of an Endpoints object. If
     * clusterIP is "None", no virtual IP is allocated and the endpoints are
     * published as a set of endpoints rather than a stable IP.
     *
     * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
     * which routes to the clusterIP.
     *
     * - `"LoadBalancer"`: Builds on NodePort and creates an external load
     * balancer (if supported in the current cloud) which routes to the
     * clusterIP.
     *
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
     * Kubernetes documentation}.
     * @defaultValue `"ClusterIP"`
     */
    type?: string;
}
/** @public */
export interface ServicePort {
    /**
     * The name of this port within the service.
     *
     * @remarks
     * This must be a DNS_LABEL.
     * All ports within a ServiceSpec must have unique names.This maps to the
     * Name' field in EndpointPort objects. Optional if only one ServicePort is
     * defined on this service.
     */
    name?: string;
    /**
     * The port on each node on which this service is exposed when
     * type=NodePort or LoadBalancer.
     *
     * @remarks
     * Usually assigned by the system. If
     * specified, it will be allocated to the service if unused or else creation
     * of the service will fail.
     *
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
     * Kubernetes documentation}.
     * @defaultValue Automatically allocates a port if the ServiceType of this
     * Service requires one.
     */
    nodePort?: number;
    /** The port that will be exposed by this service. */
    port?: number;
    /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
    protocol?: string;
    /**
     * Number or name of the port to access on the pods targeted by the
     * service.
     *
     * @remarks
     * Number must be in the range 1 to 65535. Name must be an
     * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
     * in the target Pod's container ports. If this is not specified, the value
     * of the 'port' field is used (an identity map). This field is ignored for
     * services with clusterIP = None, and should be omitted or set equal to the
     * 'port' field.
     *
     * For more information, see the
     * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
     * Kubernetes documentation}.
     */
    targetPort?: number | string;
}
/**
 * Convert {@link NetworkService} props to {@link k8s.Service} spec
 * @param abstractProps - props to convert
 * @returns Kubernetes spec corresponding to `abstractProps`
 *
 * @internal
 */
export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): ServiceSpec;
declare const defaultProps: {
    sessionAffinity: string;
    type: string;
};
/**
 * Native Kubernetes Service resource
 *
 * @remarks
 *
 * Implements the {@link NetworkServiceInstance} interface.
 *
 * @public
 */
export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.AdaptElement<Adapt.AnyProps>;
declare function deployedWhen(statusObj: unknown): true | Adapt.Waiting;
/** @internal */
export declare const serviceResourceInfo: {
    kind: string;
    apiName: string;
    deployedWhen: typeof deployedWhen;
    statusQuery: (props: ResourceProps, observe: Adapt.ObserveForStatus<unknown>, buildData: Adapt.BuildData) => Promise<any>;
};
export {};
//# sourceMappingURL=Service.d.ts.map