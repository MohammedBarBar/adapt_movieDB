import { DockerSplitRegistryInfo } from "../docker";
import { ClusterInfo, Kubeconfig } from "./common";
/**
 * Options for {@link k8s.makeClusterInfo}
 *
 * @public
 */
export interface MakeClusterInfoOptions {
    /**
     * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
     *
     * @remarks
     * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
     * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
     * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
     * environment variable).
     *
     * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
     * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
     * {@link k8s.ClusterInfo}
     */
    kubeconfig?: Kubeconfig | string;
    /**
     * URL to the docker registry that this cluster uses to pull private images.
     *
     * @remarks
     * This is identical to the `registryUrl` field in {@link k8s.ClusterInfo}.  It will
     * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
     */
    registryUrl?: string | DockerSplitRegistryInfo;
}
/**
 * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
 *
 * @remarks
 *
 * This function will take a set of options and generate a {@link k8s.ClusterInfo}
 * object that contains the kubeconfig, registryUrl for private images, and any other
 * relevant information for the cluster
 *
 * See {@link k8s.MakeClusterInfoOptions} for information on how the information
 * is computed.
 *
 * @returns A {@link k8s.ClusterInfo} object.
 *
 * @public
 */
export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;
//# sourceMappingURL=utils.d.ts.map