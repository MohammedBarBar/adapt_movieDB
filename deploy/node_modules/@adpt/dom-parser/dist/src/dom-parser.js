"use strict";
/*
 * Copyright 2018 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util = tslib_1.__importStar(require("util"));
const ld = tslib_1.__importStar(require("lodash"));
const sb = tslib_1.__importStar(require("stream-buffers"));
const xml2js = tslib_1.__importStar(require("xml2js"));
const dom_1 = require("./dom");
const rootName = "Adapt";
async function parseXML(xmlStr) {
    return new Promise((res, rej) => {
        xml2js.parseString(xmlStr, {
            explicitRoot: false,
            explicitChildren: true,
            preserveChildrenOrder: true,
            charsAsChildren: true,
            xmlns: true,
        }, (err, result) => {
            if (err != null)
                rej(err);
            else
                res(result);
        });
    });
}
function nameOf(xmlNode) {
    if (xmlNode.$ns)
        return xmlNode.$ns.local;
    return xmlNode["#name"];
}
function uriOf(xmlNode) {
    if (xmlNode.$ns)
        return xmlNode.$ns.uri;
    return "";
}
function handleShortProp(val) {
    if (/^\d/.test(val)) {
        const ret = Number(val);
        if (isNaN(ret)) {
            throw new Error("invalid short prop value \"" + val + "\"");
        }
        return ret;
    }
    else {
        return val;
    }
}
exports.handleShortProp = handleShortProp;
function isTextNode(xmlNode) {
    return xmlNode["#name"] === "__text__";
}
function extractSoleText(xmlNode) {
    if (xmlNode.$$ == null) {
        throw new Error("body missing");
    }
    if (!ld.isArray(xmlNode.$$)) {
        throw new Error("Internal Error");
    }
    if (xmlNode.$$.length > 1) {
        throw new Error("too many children");
    }
    if (xmlNode.$$.length === 0) {
        throw new Error("node has no body");
    }
    const child = xmlNode.$$[0];
    if (isTextNode(child)) {
        return child._;
    }
    else {
        throw new Error("no text node found");
    }
}
function extractDOMObject(xmlNode) {
    if (xmlNode.$$ == null)
        new Error("body missing");
    if (!ld.isArray(xmlNode.$$))
        throw new Error("Internal Error");
    if (xmlNode.$$.length > 1)
        throw new Error("too many children");
    if (xmlNode.$$.length === 0)
        throw new Error("node has no body");
    const child = xmlNode.$$[0];
    const uri = uriOf(child);
    if (!uri.startsWith("urn:"))
        throw new Error("child has bad xmlns");
    const json = extractSoleText(child);
    return new dom_1.DOMObject(uri, JSON.parse(json));
}
function handleJSON(xmlNode) {
    if (nameOf(xmlNode) !== "json") {
        throw new Error("Internal Error: Request to handle json node for non-json: " +
            util.inspect(xmlNode));
    }
    let txt = "";
    try {
        txt = extractSoleText(xmlNode);
        return JSON.parse(txt);
    }
    catch (e) {
        throw new Error("malformed json node body: " + e.message);
    }
}
function getPropsNode(xmlNode) {
    const anode = xmlNode;
    if (anode.__props__ != null) {
        return anode.__props__;
    }
    return [];
}
function extractProp(prop) {
    try {
        return JSON.parse(extractSoleText(prop));
    }
    catch (err) { /* */ }
    return extractDOMObject(prop);
}
function computeProps(xmlNodeIn) {
    const ret = {};
    const xmlNode = xmlNodeIn;
    if (xmlNode.$ != null) {
        for (const prop in xmlNode.$) {
            if (prop === "xmlns" || prop.startsWith("xmlns:"))
                continue;
            if (!Object.prototype.hasOwnProperty.apply(xmlNode.$, [prop]))
                continue;
            ret[prop] = handleShortProp(xmlNode.$[prop].value);
        }
    }
    const propsNodes = getPropsNode(xmlNode);
    if (propsNodes.length > 1) {
        throw new Error("malformed node, multiple __props__ children");
    }
    if (propsNodes.length < 1) {
        return ret;
    }
    const propsNode = propsNodes[0];
    if (propsNode.$$ != null) {
        for (const prop of propsNode.$$) {
            if (prop.$ != null) {
                const name = prop.$.name.value;
                if (ret[name] != null)
                    throw new Error("duplicate prop: " + name);
                try {
                    ret[name] = extractProp(prop);
                }
                catch (e) {
                    throw new Error("malformed prop node for " + name + ": " + e.message);
                }
            }
        }
    }
    return ret;
}
function getLifecycleNode(xmlNode) {
    const anode = xmlNode;
    if (anode.__lifecycle__ != null) {
        return anode.__lifecycle__;
    }
    return [];
}
function extractStringArray(xmlNode) {
    const dataJson = extractSoleText(xmlNode);
    if (dataJson == null)
        throw new Error(`No text data in node: ${util.inspect(xmlNode)}`);
    const data = JSON.parse(dataJson);
    if (!util.isArray(data))
        throw new Error(`text data is not an array, expecting string[]: ${util.inspect(xmlNode)}`);
    const notString = data.find((v) => !util.isString(v));
    if (notString !== undefined) {
        throw new Error(`${util.inspect(notString)} is not string, expecting string[]:` + util.inspect(xmlNode));
    }
    return data;
}
function extractString(xmlNode) {
    const dataJson = extractSoleText(xmlNode);
    if (dataJson == null)
        throw new Error(`No text data in node: ${util.inspect(xmlNode)}`);
    const data = JSON.parse(dataJson);
    if (!util.isString(data))
        throw new Error(`text data is not a string: ${util.inspect(xmlNode)}`);
    return data;
}
function augmentError(msg, f) {
    try {
        return f();
    }
    catch (e) {
        throw new Error(msg + ":" + e.message);
    }
}
function computeLifecycleInfo(xmlNode) {
    const lifecycleNodes = getLifecycleNode(xmlNode);
    if (lifecycleNodes.length > 1) {
        throw new Error(`malformed ndoe, multiple __lifecycle__ children: ${util.inspect(xmlNode)}`);
    }
    if (lifecycleNodes.length < 1)
        return;
    const lifecycleNode = lifecycleNodes[0];
    if (lifecycleNode.$$ == null)
        return;
    const ret = {};
    for (const field of lifecycleNode.$$) {
        if (field.$ == null) {
            throw new Error(`malformed node, lifecycle field with no name ${util.inspect(lifecycleNode)}`);
        }
        const fieldName = field.$.name.value;
        switch (fieldName) {
            case "stateNamespace":
                ret.stateNamespace = augmentError("extracting stateNamespace", () => extractStringArray(field));
                break;
            case "keyPath":
                ret.keyPath = augmentError("extracting keyPath", () => extractStringArray(field));
                break;
            case "path":
                ret.path = augmentError("extracting path", () => extractString(field));
                break;
            default:
                throw new Error(`malformed node, ` +
                    `uknown lifecycle field name "${fieldName}": ${util.inspect(lifecycleNode)}`);
        }
    }
    const nodeInfo = util.inspect(xmlNode);
    if (ret.stateNamespace === undefined)
        throw new Error(`no stateNamespace in lifecycle data: ${nodeInfo}`);
    if (ret.keyPath === undefined)
        throw new Error(`no keyPath in lifecycle data: ${nodeInfo}`);
    if (ret.path === undefined)
        throw new Error(`no path in lifecycle data: ${nodeInfo}`);
    return ret;
}
function buildFromXMLNode(xmlNode) {
    const name = nameOf(xmlNode);
    const uri = uriOf(xmlNode);
    const props = computeProps(xmlNode);
    const lifecycle = computeLifecycleInfo(xmlNode);
    const children = [];
    if (xmlNode.$$ != null) {
        if (ld.isArray(xmlNode.$$)) {
            for (const child of xmlNode.$$) {
                if (ld.isObject(child)) {
                    if (nameOf(child) === "__props__") {
                        continue;
                    }
                    else if (nameOf(child) === "__lifecycle__") {
                        continue;
                    }
                    else if (nameOf(child) === "json") {
                        children.push(handleJSON(child));
                    }
                    else {
                        children.push(buildFromXMLNode(child));
                    }
                }
                else {
                    children.push(child);
                }
            }
        }
        else {
            throw new Error("Internal parse error");
        }
    }
    return new dom_1.DOMNode(name, props, lifecycle, uri, children);
}
async function domFromXMLObj(xmlObj) {
    if (nameOf(xmlObj) !== rootName) {
        throw new Error("Unknown root node: " + nameOf(xmlObj));
    }
    const topLevel = xmlObj.$$;
    if (topLevel == null) {
        return null;
    }
    if (!ld.isArray(topLevel)) {
        throw new Error("Internal error parsing DOM");
    }
    if (topLevel.length === 0) {
        return null;
    }
    if (topLevel.length > 1) {
        throw new Error("Too many elements at root, must have single DOM Node");
    }
    //console.log(util.inspect(xmlObj));
    return buildFromXMLNode(topLevel[0]);
}
exports.domFromXMLObj = domFromXMLObj;
async function domFromString(xmlStr) {
    const xmlObj = await parseXML(xmlStr);
    if (xmlObj == null)
        throw new Error(`Invalid empty XML`);
    return domFromXMLObj(xmlObj);
}
exports.domFromString = domFromString;
async function stringFromStream(ins) {
    return new Promise((res, rej) => {
        const buf = new sb.WritableStreamBuffer();
        ins.pipe(buf);
        buf.on("close", () => res(buf.getContentsAsString() || undefined));
        buf.on("error", (e) => rej(e));
    });
}
async function domFromStream(ins) {
    const xmlStr = await stringFromStream(ins);
    return domFromString(xmlStr);
}
exports.domFromStream = domFromStream;
//# sourceMappingURL=dom-parser.js.map